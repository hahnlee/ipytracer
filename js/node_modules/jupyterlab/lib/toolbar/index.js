// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var properties_1 = require('phosphor/lib/core/properties');
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
/**
 * The class name added to toolbars.
 */
var TOOLBAR_CLASS = 'jp-Toolbar';
/**
 * The class name added to toolbar items.
 */
var TOOLBAR_ITEM_CLASS = 'jp-Toolbar-item';
/**
 * The class name added to toolbar buttons.
 */
var TOOLBAR_BUTTON_CLASS = 'jp-Toolbar-button';
/**
 * The class name added to a pressed button.
 */
var TOOLBAR_PRESSED_CLASS = 'jp-mod-pressed';
/**
 * A class which provides a toolbar widget.
 */
var Toolbar = (function (_super) {
    __extends(Toolbar, _super);
    /**
     * Construct a new toolbar widget.
     */
    function Toolbar() {
        _super.call(this);
        this.addClass(TOOLBAR_CLASS);
        this.layout = new panel_1.PanelLayout();
    }
    /**
     * Get an iterator over the ordered toolbar item names.
     *
     * @returns An iterator over the toolbar item names.
     */
    Toolbar.prototype.names = function () {
        var layout = this.layout;
        return iteration_1.map(layout.widgets, function (widget) {
            return Private.nameProperty.get(widget);
        });
    };
    /**
     * Add an item to the end of the toolbar.
     *
     * @param name - The name of the widget to add to the toolbar.
     *
     * @param widget - The widget to add to the toolbar.
     *
     * @param index - The optional name of the item to insert after.
     *
     * @returns Whether the item was added to toolbar.  Returns false if
     *   an item of the same name is already in the toolbar.
     */
    Toolbar.prototype.addItem = function (name, widget) {
        var layout = this.layout;
        return this.insertItem(layout.widgets.length, name, widget);
    };
    /**
     * Insert an item into the toolbar at the specified index.
     *
     * @param index - The index at which to insert the item.
     *
     * @param name - The name of the item.
     *
     * @param widget - The widget to add.
     *
     * @returns Whether the item was added to the toolbar. Returns false if
     *   an item of the same name is already in the toolbar.
     *
     * #### Notes
     * The index will be clamped to the bounds of the items.
     */
    Toolbar.prototype.insertItem = function (index, name, widget) {
        var existing = searching_1.find(this.names(), function (value) { return value === name; });
        if (existing) {
            return false;
        }
        widget.addClass(TOOLBAR_ITEM_CLASS);
        var layout = this.layout;
        layout.insertWidget(index, widget);
        Private.nameProperty.set(widget, name);
        return true;
    };
    /**
     * Remove an item in the toolbar by value.
     *
     *  @param name - The name of the widget to remove from the toolbar.
     */
    Toolbar.prototype.removeItem = function (widget) {
        var layout = this.layout;
        layout.removeWidget(widget);
    };
    return Toolbar;
}(widget_1.Widget));
exports.Toolbar = Toolbar;
/**
 * A widget which acts as a button in a toolbar.
 */
var ToolbarButton = (function (_super) {
    __extends(ToolbarButton, _super);
    /**
     * Construct a new toolbar button.
     */
    function ToolbarButton(options) {
        if (options === void 0) { options = {}; }
        _super.call(this, { node: document.createElement('span') });
        options = options || {};
        this.addClass(TOOLBAR_BUTTON_CLASS);
        this._onClick = options.onClick;
        if (options.className) {
            this.addClass(options.className);
        }
        this.node.title = options.tooltip || '';
    }
    /**
     * Dispose of the resources held by the widget.
     */
    ToolbarButton.prototype.dispose = function () {
        this._onClick = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    ToolbarButton.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                if (this._onClick) {
                    this._onClick();
                }
                break;
            case 'mousedown':
                this.addClass(TOOLBAR_PRESSED_CLASS);
                break;
            case 'mouseup':
            case 'mouseout':
                this.removeClass(TOOLBAR_PRESSED_CLASS);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after-attach` messages for the widget.
     */
    ToolbarButton.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('mouseup', this);
        this.node.addEventListener('mouseout', this);
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    ToolbarButton.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('mouseup', this);
        this.node.removeEventListener('mouseout', this);
    };
    return ToolbarButton;
}(widget_1.Widget));
exports.ToolbarButton = ToolbarButton;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the name of a toolbar item.
     */
    Private.nameProperty = new properties_1.AttachedProperty({ name: 'name' });
})(Private || (Private = {}));
//# sourceMappingURL=index.js.map