// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var dialog_1 = require('../dialog');
/**
 * Bring up a dialog to select a kernel.
 */
function selectKernel(options) {
    var specs = options.specs, kernel = options.kernel, sessions = options.sessions, preferredLanguage = options.preferredLanguage;
    // Create the dialog body.
    var body = document.createElement('div');
    var text = document.createElement('pre');
    text.textContent = "Select kernel for\n\"" + options.name + "\"";
    body.appendChild(text);
    if (kernel) {
        var displayName = specs.kernelspecs[kernel.name].display_name;
        text.textContent += "\nCurrent: " + displayName;
        text.title = ("Kernel Name: " + displayName + "\n") +
            ("Kernel Id: " + kernel.id);
    }
    var selector = document.createElement('select');
    body.appendChild(selector);
    // Get the current sessions, populate the kernels, and show the dialog.
    populateKernels(selector, { specs: specs, sessions: sessions, preferredLanguage: preferredLanguage, kernel: kernel });
    return dialog_1.showDialog({
        title: 'Select Kernel',
        body: body,
        okText: 'SELECT'
    }).then(function (result) {
        // Change the kernel if a kernel was selected.
        if (result.text === 'SELECT') {
            return JSON.parse(selector.value);
        }
        return void 0;
    });
}
exports.selectKernel = selectKernel;
/**
 * Change the kernel on a context.
 */
function selectKernelForContext(context, manager, host) {
    return manager.ready.then(function () {
        var options = {
            name: context.path.split('/').pop(),
            specs: manager.specs,
            sessions: manager.running(),
            preferredLanguage: context.model.defaultKernelLanguage,
            kernel: context.kernel ? context.kernel.model : null,
            host: host
        };
        return selectKernel(options);
    }).then(function (kernel) {
        if (kernel) {
            context.changeKernel(kernel);
        }
    });
}
exports.selectKernelForContext = selectKernelForContext;
/**
 * Get the appropriate kernel name.
 */
function findKernel(kernelName, language, specs) {
    if (kernelName === 'unknown') {
        return specs.default;
    }
    // Look for an exact match.
    for (var specName in specs.kernelspecs) {
        if (specName === kernelName) {
            return kernelName;
        }
    }
    // Next try to match the language name.
    if (language === 'unknown') {
        return specs.default;
    }
    for (var specName in specs.kernelspecs) {
        var kernelLanguage = specs.kernelspecs[specName].language;
        if (language === kernelLanguage) {
            console.log('No exact match found for ' + specName +
                ', using kernel ' + specName + ' that matches ' +
                'language=' + language);
            return specName;
        }
    }
    // Finally, use the default kernel.
    if (kernelName) {
        console.log(("No matching kernel found for " + kernelName + ", ") +
            ("using default kernel " + specs.default));
    }
    return specs.default;
}
exports.findKernel = findKernel;
/**
 * Populate a kernel dropdown list.
 *
 * @param node - The host node.
 *
 * @param options - The options used to populate the kernels.
 *
 * #### Notes
 * Populates the list with separated sections:
 *   - Kernels matching the preferred language (display names).
 *   - "None" signifying no kernel.
 *   - The remaining kernels.
 *   - Sessions matching the preferred language (file names).
 *   - The remaining sessions.
 * If no preferred language is given or no kernels are found using
 * the preferred language, the default kernel is used in the first
 * section.  Kernels are sorted by display name.  Sessions display the
 * base name of the file with an ellipsis overflow and a tooltip with
 * the explicit session information.
 */
function populateKernels(node, options) {
    // Clear any existing options.
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
    var maxLength = 10;
    var preferredKernel = options.preferredKernel, preferredLanguage = options.preferredLanguage, sessions = options.sessions, specs = options.specs, kernel = options.kernel;
    var existing = kernel ? kernel.id : void 0;
    // Create mappings of display names and languages for kernel name.
    var displayNames = Object.create(null);
    var languages = Object.create(null);
    for (var name_1 in specs.kernelspecs) {
        var spec = specs.kernelspecs[name_1];
        displayNames[name_1] = spec.display_name;
        maxLength = Math.max(maxLength, displayNames[name_1].length);
        languages[name_1] = spec.language;
    }
    // Handle a kernel by name.
    var names = [];
    if (preferredKernel && preferredKernel in specs.kernelspecs) {
        names.push(name);
    }
    // Handle a preferred kernel language in order of display name.
    if (preferredLanguage && specs) {
        for (var name_2 in specs.kernelspecs) {
            if (languages[name_2] === preferredLanguage) {
                names.push(name_2);
            }
        }
        names.sort(function (a, b) { return displayNames[a].localeCompare(displayNames[b]); });
        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
            var name_3 = names_1[_i];
            node.appendChild(optionForName(name_3, displayNames[name_3]));
        }
    }
    // Use the default kernel if no preferred language or none were found.
    if (!names.length) {
        var name_4 = specs.default;
        node.appendChild(optionForName(name_4, displayNames[name_4]));
    }
    // Add a separator.
    node.appendChild(createSeparatorOption(maxLength));
    // Add the rest of the kernel names in alphabetical order.
    var otherNames = [];
    for (var name_5 in specs.kernelspecs) {
        if (names.indexOf(name_5) !== -1) {
            continue;
        }
        otherNames.push(name_5);
    }
    otherNames.sort(function (a, b) { return displayNames[a].localeCompare(displayNames[b]); });
    for (var _a = 0, otherNames_1 = otherNames; _a < otherNames_1.length; _a++) {
        var name_6 = otherNames_1[_a];
        node.appendChild(optionForName(name_6, displayNames[name_6]));
    }
    // Add a separator option if there were any other names.
    if (otherNames.length) {
        node.appendChild(createSeparatorOption(maxLength));
    }
    // Add the sessions using the preferred language first.
    var matchingSessions = [];
    var otherSessions = [];
    iteration_1.each(sessions, function (session) {
        if (preferredLanguage &&
            languages[session.kernel.name] === preferredLanguage &&
            session.kernel.id !== existing) {
            matchingSessions.push(session);
        }
        else if (session.kernel.id !== existing) {
            otherSessions.push(session);
        }
    });
    if (matchingSessions) {
        matchingSessions.sort(function (a, b) {
            return a.notebook.path.localeCompare(b.notebook.path);
        });
        iteration_1.each(matchingSessions, function (session) {
            var name = displayNames[session.kernel.name];
            node.appendChild(optionForSession(session, name, maxLength));
        });
        node.appendChild(createSeparatorOption(maxLength));
    }
    if (otherSessions) {
        otherSessions.sort(function (a, b) {
            return a.notebook.path.localeCompare(b.notebook.path);
        });
        iteration_1.each(otherSessions, function (session) {
            var name = displayNames[session.kernel.name] || session.kernel.name;
            node.appendChild(optionForSession(session, name, maxLength));
        });
    }
    node.selectedIndex = 0;
}
exports.populateKernels = populateKernels;
/**
 * Create a separator option.
 */
function createSeparatorOption(length) {
    var option = document.createElement('option');
    option.disabled = true;
    option.text = Array(length).join('â”€');
    return option;
}
/**
 * Create an option element for a kernel name.
 */
function optionForName(name, displayName) {
    var option = document.createElement('option');
    option.text = displayName;
    option.value = JSON.stringify({ name: name });
    return option;
}
/**
 * Create an option element for a session.
 */
function optionForSession(session, displayName, maxLength) {
    var option = document.createElement('option');
    var sessionName = session.notebook.path.split('/').pop();
    var CONSOLE_REGEX = /^console-(\d)+-[0-9a-f]+$/;
    if (CONSOLE_REGEX.test(sessionName)) {
        sessionName = "Console " + sessionName.match(CONSOLE_REGEX)[1];
    }
    if (sessionName.length > maxLength) {
        sessionName = sessionName.slice(0, maxLength - 3) + '...';
    }
    option.text = sessionName;
    option.value = JSON.stringify({ id: session.kernel.id });
    option.title = ("Path: " + session.notebook.path + "\n") +
        ("Kernel Name: " + displayName + "\n") +
        ("Kernel Id: " + session.kernel.id);
    return option;
}
//# sourceMappingURL=kernelselector.js.map