// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var signaling_1 = require('phosphor/lib/core/signaling');
var token_1 = require('phosphor/lib/core/token');
var panel_1 = require('phosphor/lib/ui/panel');
var tabpanel_1 = require('phosphor/lib/ui/tabpanel');
var toolbar_1 = require('../toolbar');
/**
 * The class name added to inspector panels.
 */
var PANEL_CLASS = 'jp-Inspector';
/**
 * The class name added to inspector child item widgets.
 */
var ITEM_CLASS = 'jp-InspectorItem';
/**
 * The class name added to inspector child item widgets' content.
 */
var CONTENT_CLASS = 'jp-InspectorItem-content';
/**
 * The history clear button class name.
 */
var CLEAR_CLASS = 'jp-InspectorItem-clear';
/**
 * The back button class name.
 */
var BACK_CLASS = 'jp-InspectorItem-back';
/**
 * The forward button class name.
 */
var FORWARD_CLASS = 'jp-InspectorItem-forward';
/* tslint:disable */
/**
 * The inspector panel token.
 */
exports.IInspector = new token_1.Token('jupyter.services.inspector');
/**
 * A panel which contains a set of inspectors.
 */
var Inspector = (function (_super) {
    __extends(Inspector, _super);
    /**
     * Construct an inspector.
     */
    function Inspector(options) {
        var _this = this;
        _super.call(this);
        this._items = Object.create(null);
        this._source = null;
        this.addClass(PANEL_CLASS);
        var items = options.items || [];
        // Create inspector child items and add them to the inspectors panel.
        items.forEach(function (value) {
            var widget = value.widget || new InspectorItem();
            widget.rank = value.rank;
            widget.remembers = !!value.remembers;
            widget.title.closable = false;
            widget.title.label = value.name;
            if (value.className) {
                widget.addClass(value.className);
            }
            _this._items[value.type] = widget;
            _this.addWidget(widget);
        });
        if (items.length < 2) {
            this.tabBar.hide();
        }
    }
    Object.defineProperty(Inspector.prototype, "source", {
        /**
         * The source of events the inspector panel listens for.
         */
        get: function () {
            return this._source;
        },
        set: function (source) {
            var _this = this;
            if (this._source === source) {
                return;
            }
            // Disconnect old signal handler.
            if (this._source) {
                this._source.inspected.disconnect(this.onInspectorUpdate, this);
                this._source.disposed.disconnect(this.onSourceDisposed, this);
            }
            // Clear the inspector child items (but maintain history) if necessary.
            if (this._items) {
                Object.keys(this._items).forEach(function (i) { return _this._items[i].content = null; });
            }
            this._source = source;
            // Connect new signal handler.
            if (this._source) {
                this._source.inspected.connect(this.onInspectorUpdate, this);
                this._source.disposed.connect(this.onSourceDisposed, this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    Inspector.prototype.dispose = function () {
        var _this = this;
        if (this.isDisposed) {
            return;
        }
        // Dispose the inspector child items.
        Object.keys(this._items).forEach(function (i) { return _this._items[i].dispose(); });
        this._items = null;
        // Disconnect from source.
        this.source = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `'close-request'` messages.
     */
    Inspector.prototype.onCloseRequest = function (msg) {
        _super.prototype.onCloseRequest.call(this, msg);
        this.dispose();
    };
    /**
     * Handle inspector update signals.
     */
    Inspector.prototype.onInspectorUpdate = function (sender, args) {
        var widget = this._items[args.type];
        if (!widget) {
            return;
        }
        // Update the content of the inspector widget.
        widget.content = args.content;
        var items = this._items;
        // If any inspector with a higher rank has content, do not change focus.
        if (args.content) {
            for (var type in items) {
                var inspector = this._items[type];
                if (inspector.rank < widget.rank && inspector.content) {
                    return;
                }
            }
            this.currentWidget = widget;
            return;
        }
        // If the inspector was emptied, show the next best ranked inspector.
        var lowest = Infinity;
        widget = null;
        for (var type in items) {
            var inspector = this._items[type];
            if (inspector.rank < lowest && inspector.content) {
                lowest = inspector.rank;
                widget = inspector;
            }
        }
        if (widget) {
            this.currentWidget = widget;
        }
    };
    /**
     * Handle source disposed signals.
     */
    Inspector.prototype.onSourceDisposed = function (sender, args) {
        this.source = null;
    };
    return Inspector;
}(tabpanel_1.TabPanel));
exports.Inspector = Inspector;
/**
 * A code inspector child widget.
 */
var InspectorItem = (function (_super) {
    __extends(InspectorItem, _super);
    /**
     * Construct an inspector widget.
     */
    function InspectorItem() {
        _super.call(this);
        this._content = null;
        this._history = null;
        this._index = -1;
        this._rank = Infinity;
        this._remembers = false;
        this._toolbar = null;
        this.addClass(ITEM_CLASS);
        this._toolbar = this._createToolbar();
        this.addWidget(this._toolbar);
    }
    Object.defineProperty(InspectorItem.prototype, "content", {
        /**
         * The text of the inspector.
         */
        get: function () {
            return this._content;
        },
        set: function (newValue) {
            if (newValue === this._content) {
                return;
            }
            if (this._content) {
                if (this._remembers) {
                    this._content.hide();
                }
                else {
                    this._content.dispose();
                }
            }
            this._content = newValue;
            if (this._content) {
                this._content.addClass(CONTENT_CLASS);
                this.addWidget(this._content);
                if (this.remembers) {
                    this._history.push(newValue);
                    this._index++;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InspectorItem.prototype, "remembers", {
        /**
         * A flag that indicates whether the inspector remembers history.
         */
        get: function () {
            return this._remembers;
        },
        set: function (newValue) {
            if (newValue === this._remembers) {
                return;
            }
            this._clear();
            this._remembers = newValue;
            if (!this._remembers) {
                this._history = null;
            }
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InspectorItem.prototype, "rank", {
        /**
         * The display rank of the inspector.
         */
        get: function () {
            return this._rank;
        },
        set: function (newValue) {
            this._rank = newValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    InspectorItem.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        signaling_1.clearSignalData(this);
        if (this._history) {
            this._history.forEach(function (widget) { return widget.dispose(); });
            this._history = null;
        }
        if (this._toolbar) {
            this._toolbar.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * Navigate back in history.
     */
    InspectorItem.prototype._back = function () {
        if (this._history.length) {
            this._navigateTo(Math.max(this._index - 1, 0));
        }
    };
    /**
     * Clear history.
     */
    InspectorItem.prototype._clear = function () {
        if (this._history) {
            this._history.forEach(function (widget) { return widget.dispose(); });
        }
        this._history = [];
        this._index = -1;
    };
    /**
     * Navigate forward in history.
     */
    InspectorItem.prototype._forward = function () {
        if (this._history.length) {
            this._navigateTo(Math.min(this._index + 1, this._history.length - 1));
        }
    };
    /**
     * Create a history toolbar.
     */
    InspectorItem.prototype._createToolbar = function () {
        var _this = this;
        var toolbar = new toolbar_1.Toolbar();
        if (!this._remembers) {
            return toolbar;
        }
        var clear = new toolbar_1.ToolbarButton({
            className: CLEAR_CLASS,
            onClick: function () { _this._clear(); },
            tooltip: 'Clear history.'
        });
        toolbar.addItem('clear', clear);
        var back = new toolbar_1.ToolbarButton({
            className: BACK_CLASS,
            onClick: function () { _this._back(); },
            tooltip: 'Navigate back in history.'
        });
        toolbar.addItem('back', back);
        var forward = new toolbar_1.ToolbarButton({
            className: FORWARD_CLASS,
            onClick: function () { _this._forward(); },
            tooltip: 'Navigate forward in history.'
        });
        toolbar.addItem('forward', forward);
        return toolbar;
    };
    /**
     * Navigate to a known index in history.
     */
    InspectorItem.prototype._navigateTo = function (index) {
        if (this._content) {
            this._content.hide();
        }
        this._content = this._history[index];
        this._index = index;
        this._content.show();
    };
    return InspectorItem;
}(panel_1.Panel));
exports.InspectorItem = InspectorItem;
//# sourceMappingURL=inspector.js.map