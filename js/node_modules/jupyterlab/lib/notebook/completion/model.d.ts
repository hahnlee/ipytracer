import { JSONObject } from 'phosphor/lib/algorithm/json';
import { IDisposable } from 'phosphor/lib/core/disposable';
import { ISignal } from 'phosphor/lib/core/signaling';
import { ICompletionRequest, ITextChange } from '../cells/editor';
/**
 * An object describing a completion option injection into text.
 */
export interface ICompletionPatch {
    /**
     * The patch text.
     */
    text: string;
    /**
     * The position in the text where cursor should be after patch application.
     */
    position: number;
}
/**
 * A completion menu item.
 */
export interface ICompletionItem {
    /**
     * The highlighted, marked up text of a visible completion item.
     */
    text: string;
    /**
     * The raw text of a visible completion item.
     */
    raw: string;
}
/**
 * A cursor span.
 */
export interface ICursorSpan extends JSONObject {
    /**
     * The start position of the cursor.
     */
    start: number;
    /**
     * The end position of the cursor.
     */
    end: number;
}
/**
 * The data model backing a code completion widget.
 */
export interface ICompletionModel extends IDisposable {
    /**
     * A signal emitted when state of the completion menu changes.
     */
    stateChanged: ISignal<ICompletionModel, void>;
    /**
     * The current text change details.
     */
    current: ITextChange;
    /**
     * The cursor details that the API has used to return matching options.
     */
    cursor: ICursorSpan;
    /**
     * The list of visible items in the completion menu.
     */
    items: ICompletionItem[];
    /**
     * The unfiltered list of all available options in a completion menu.
     */
    options: string[];
    /**
     * The original completion request details.
     */
    original: ICompletionRequest;
    /**
     * The query against which items are filtered.
     */
    query: string;
    /**
     * Handle a text change.
     */
    handleTextChange(change: ITextChange): void;
    /**
     * Create a resolved patch between the original state and a patch string.
     */
    createPatch(patch: string): ICompletionPatch;
    /**
     * Reset the state of the model.
     */
    reset(): void;
}
/**
 * An implementation of a completion model.
 */
export declare class CompletionModel implements ICompletionModel {
    /**
     * A signal emitted when state of the completion menu changes.
     */
    stateChanged: ISignal<ICompletionModel, void>;
    /**
     * The list of visible items in the completion menu.
     *
     * #### Notes
     * This is a read-only property.
     */
    items: ICompletionItem[];
    /**
     * The unfiltered list of all available options in a completion menu.
     */
    options: string[];
    /**
     * The original completion request details.
     */
    original: ICompletionRequest;
    /**
     * The current text change details.
     */
    current: ITextChange;
    /**
     * The cursor details that the API has used to return matching options.
     */
    cursor: ICursorSpan;
    /**
     * The query against which items are filtered.
     */
    query: string;
    /**
     * Get whether the model is disposed.
     */
    isDisposed: boolean;
    /**
     * Dispose of the resources held by the model.
     */
    dispose(): void;
    /**
     * Handle a text change.
     */
    handleTextChange(change: ITextChange): void;
    /**
     * Create a resolved patch between the original state and a patch string.
     *
     * @param patch - The patch string to apply to the original value.
     *
     * @returns A patched text change or null if original value did not exist.
     */
    createPatch(patch: string): ICompletionPatch;
    /**
     * Reset the state of the model and emit a state change signal.
     */
    reset(): void;
    /**
     * Apply the query to the complete options list to return the matching subset.
     */
    private _filter();
    /**
     * Reset the state of the model.
     */
    private _reset();
    private _isDisposed;
    private _options;
    private _original;
    private _current;
    private _query;
    private _cursor;
}
