// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var mimedata_1 = require('phosphor/lib/core/mimedata');
var signaling_1 = require('phosphor/lib/core/signaling');
var dragdrop_1 = require('phosphor/lib/dom/dragdrop');
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
/**
 * The threshold in pixels to start a drag event.
 */
var DRAG_THRESHOLD = 5;
/**
 * The factory MIME type supported by phosphor dock panels.
 */
var FACTORY_MIME = 'application/vnd.phosphor.widget-factory';
/**
 * The class name added to an output area widget.
 */
var OUTPUT_AREA_CLASS = 'jp-OutputArea';
/**
 * The class name added to a "mirrored" output area widget created by a drag.
 */
var MIRRORED_OUTPUT_AREA_CLASS = 'jp-MirroredOutputArea';
/**
 * The class name added to an output widget.
 */
var OUTPUT_CLASS = 'jp-Output';
/**
 * The class name added to an execute result.
 */
var EXECUTE_CLASS = 'jp-Output-executeResult';
/**
 * The class name added to display data.
 */
var DISPLAY_CLASS = 'jp-Output-displayData';
/**
 * The class name added to stdout data.
 */
var STDOUT_CLASS = 'jp-Output-stdout';
/**
 * The class name added to stderr data.
 */
var STDERR_CLASS = 'jp-Output-stderr';
/**
 * The class name added to error data.
 */
var ERROR_CLASS = 'jp-Output-error';
/**
 * The class name added to stdin data.
 */
var STDIN_CLASS = 'jp-Output-stdin';
/**
 * The class name added to stdin data prompt nodes.
 */
var STDIN_PROMPT_CLASS = 'jp-Output-stdinPrompt';
/**
 * The class name added to stdin data input nodes.
 */
var STDIN_INPUT_CLASS = 'jp-Output-stdinInput';
/**
 * The class name added to stdin rendered text nodes.
 */
var STDIN_RENDERED_CLASS = 'jp-Output-stdinRendered';
/**
 * The class name added to fixed height output areas.
 */
var FIXED_HEIGHT_CLASS = 'jp-mod-fixedHeight';
/**
 * The class name added to collaped output areas.
 */
var COLLAPSED_CLASS = 'jp-mod-collapsed';
/**
 * The class name added to output area prompts.
 */
var PROMPT_CLASS = 'jp-Output-prompt';
/**
 * The class name added to output area results.
 */
var RESULT_CLASS = 'jp-Output-result';
/**
 * An output area widget.
 *
 * #### Notes
 * The widget model must be set separately and can be changed
 * at any time.  Consumers of the widget must account for a
 * `null` model, and may want to listen to the `modelChanged`
 * signal.
 */
var OutputAreaWidget = (function (_super) {
    __extends(OutputAreaWidget, _super);
    /**
     * Construct an output area widget.
     */
    function OutputAreaWidget(options) {
        _super.call(this);
        this._trusted = false;
        this._fixedHeight = false;
        this._collapsed = false;
        this._minHeightTimeout = null;
        this._model = null;
        this._rendermime = null;
        this._renderer = null;
        this._injecting = false;
        this.addClass(OUTPUT_AREA_CLASS);
        this._rendermime = options.rendermime;
        this._renderer = options.renderer || OutputAreaWidget.defaultRenderer;
        this.layout = new panel_1.PanelLayout();
    }
    /**
     * Create a mirrored output widget.
     */
    OutputAreaWidget.prototype.mirror = function () {
        var rendermime = this._rendermime;
        var renderer = this._renderer;
        var widget = new OutputAreaWidget({ rendermime: rendermime, renderer: renderer });
        widget.model = this._model;
        widget.trusted = this._trusted;
        widget.title.label = 'Mirrored Output';
        widget.title.closable = true;
        widget.addClass(MIRRORED_OUTPUT_AREA_CLASS);
        return widget;
    };
    Object.defineProperty(OutputAreaWidget.prototype, "widgets", {
        /**
         * A read-only sequence of the widgets in the output area.
         */
        get: function () {
            return this.layout.widgets;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaWidget.prototype, "model", {
        /**
         * The model for the widget.
         */
        get: function () {
            return this._model;
        },
        set: function (newValue) {
            if (!newValue && !this._model || newValue === this._model) {
                return;
            }
            var oldValue = this._model;
            this._model = newValue;
            // Trigger private, protected, and public updates.
            this._onModelChanged(oldValue, newValue);
            this.onModelChanged(oldValue, newValue);
            this.modelChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaWidget.prototype, "rendermime", {
        /**
         * Get the rendermime instance used by the widget.
         */
        get: function () {
            return this._rendermime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaWidget.prototype, "renderer", {
        /**
         * Get the renderer used by the widget.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaWidget.prototype, "trusted", {
        /**
         * The trusted state of the widget.
         */
        get: function () {
            return this._trusted;
        },
        set: function (value) {
            if (this._trusted === value) {
                return;
            }
            this._trusted = value;
            // Trigger a update of the child widgets.
            var layout = this.layout;
            for (var i = 0; i < layout.widgets.length; i++) {
                this.updateChild(i);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaWidget.prototype, "collapsed", {
        /**
         * The collapsed state of the widget.
         */
        get: function () {
            return this._collapsed;
        },
        set: function (value) {
            if (this._collapsed === value) {
                return;
            }
            this._collapsed = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaWidget.prototype, "fixedHeight", {
        /**
         * The fixed height state of the widget.
         */
        get: function () {
            return this._fixedHeight;
        },
        set: function (value) {
            if (this._fixedHeight === value) {
                return;
            }
            this._fixedHeight = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    OutputAreaWidget.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._model = null;
        this._rendermime = null;
        this._renderer = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `update-request` messages.
     */
    OutputAreaWidget.prototype.onUpdateRequest = function (msg) {
        if (this.collapsed) {
            this.addClass(COLLAPSED_CLASS);
        }
        else {
            this.removeClass(COLLAPSED_CLASS);
        }
        if (this.fixedHeight) {
            this.addClass(FIXED_HEIGHT_CLASS);
        }
        else {
            this.removeClass(FIXED_HEIGHT_CLASS);
        }
    };
    /**
     * Add a child to the layout.
     */
    OutputAreaWidget.prototype.addChild = function () {
        var widget = this._renderer.createOutput({ rendermime: this.rendermime });
        var layout = this.layout;
        layout.addWidget(widget);
        this.updateChild(layout.widgets.length - 1);
    };
    /**
     * Remove a child from the layout.
     */
    OutputAreaWidget.prototype.removeChild = function (index) {
        var layout = this.layout;
        layout.widgets.at(index).dispose();
    };
    /**
     * Update a child in the layout.
     */
    OutputAreaWidget.prototype.updateChild = function (index) {
        var _this = this;
        var layout = this.layout;
        var widget = layout.widgets.at(index);
        var output = this._model.get(index);
        var injector;
        if (output.output_type === 'display_data' ||
            output.output_type === 'execute_result') {
            injector = function (mimetype, value) {
                _this._injecting = true;
                _this._model.addMimeData(output, mimetype, value);
                _this._injecting = false;
            };
        }
        var trusted = this._trusted;
        widget.render({ output: output, trusted: trusted, injector: injector });
    };
    /**
     * Follow changes on the model state.
     */
    OutputAreaWidget.prototype.onModelStateChanged = function (sender, args) {
        var _this = this;
        switch (args.type) {
            case 'add':
                // Children are always added at the end.
                this.addChild();
                break;
            case 'remove':
                // Only "clear" is supported by the model.
                // When an output area is cleared and then quickly replaced with new
                // content (as happens with @interact in widgets, for example), the
                // quickly changing height can make the page jitter.
                // We introduce a small delay in the minimum height
                // to prevent this jitter.
                var rect = this.node.getBoundingClientRect();
                this.node.style.minHeight = rect.height + "px";
                if (this._minHeightTimeout) {
                    clearTimeout(this._minHeightTimeout);
                }
                this._minHeightTimeout = setTimeout(function () {
                    if (_this.isDisposed) {
                        return;
                    }
                    _this.node.style.minHeight = '';
                }, 50);
                iteration_1.each(args.oldValues, function (value) {
                    _this.removeChild(args.oldIndex);
                });
                break;
            case 'set':
                if (!this._injecting) {
                    this.updateChild(args.newIndex);
                }
                break;
            default:
                break;
        }
        this.update();
    };
    /**
     * Handle a new model.
     *
     * #### Notes
     * This method is called after the model change has been handled
     * internally and before the `modelChanged` signal is emitted.
     * The default implementation is a no-op.
     */
    OutputAreaWidget.prototype.onModelChanged = function (oldValue, newValue) {
        // no-op
    };
    /**
     * Handle a change to the model.
     */
    OutputAreaWidget.prototype._onModelChanged = function (oldValue, newValue) {
        var layout = this.layout;
        if (oldValue) {
            oldValue.changed.disconnect(this.onModelStateChanged, this);
            oldValue.disposed.disconnect(this._onModelDisposed, this);
        }
        var start = newValue ? newValue.length : 0;
        // Clear unnecessary child widgets.
        for (var i = start; i < layout.widgets.length; i++) {
            this.removeChild(i);
        }
        if (!newValue) {
            return;
        }
        newValue.changed.connect(this.onModelStateChanged, this);
        newValue.disposed.connect(this._onModelDisposed, this);
        // Reuse existing child widgets.
        for (var i = 0; i < layout.widgets.length; i++) {
            this.updateChild(i);
        }
        // Add new widgets as necessary.
        for (var i = layout.widgets.length; i < newValue.length; i++) {
            this.addChild();
        }
    };
    /**
     * Handle a model disposal.
     */
    OutputAreaWidget.prototype.onModelDisposed = function (oldValue, newValue) {
        // no-op
    };
    OutputAreaWidget.prototype._onModelDisposed = function () {
        this.modelDisposed.emit(void 0);
        this.dispose();
    };
    return OutputAreaWidget;
}(widget_1.Widget));
exports.OutputAreaWidget = OutputAreaWidget;
/**
 * A namespace for OutputAreaWidget statics.
 */
var OutputAreaWidget;
(function (OutputAreaWidget) {
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create an output widget.
         *
         *
         * @returns A new widget for an output.
         */
        Renderer.prototype.createOutput = function (options) {
            return new OutputWidget(options);
        };
        return Renderer;
    }());
    OutputAreaWidget.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    OutputAreaWidget.defaultRenderer = new Renderer();
})(OutputAreaWidget = exports.OutputAreaWidget || (exports.OutputAreaWidget = {}));
/**
 * The gutter on the left side of the OutputWidget
 */
var OutputGutter = (function (_super) {
    __extends(OutputGutter, _super);
    function OutputGutter() {
        _super.apply(this, arguments);
        this._drag = null;
        this._dragData = null;
    }
    /**
     * Handle the DOM events for the output gutter widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    OutputGutter.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mousedown':
                this._evtMousedown(event);
                break;
            case 'mouseup':
                this._evtMouseup(event);
                break;
            case 'mousemove':
                this._evtMousemove(event);
                break;
            default:
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    OutputGutter.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    OutputGutter.prototype.onBeforeDetach = function (msg) {
        _super.prototype.onBeforeDetach.call(this, msg);
        var node = this.node;
        node.removeEventListener('mousedown', this);
    };
    /**
     * Handle the `'mousedown'` event for the widget.
     */
    OutputGutter.prototype._evtMousedown = function (event) {
        // Left mouse press for drag start.
        if (event.button === 0) {
            this._dragData = { pressX: event.clientX, pressY: event.clientY };
            document.addEventListener('mouseup', this, true);
            document.addEventListener('mousemove', this, true);
        }
    };
    /**
     * Handle the `'mouseup'` event for the widget.
     */
    OutputGutter.prototype._evtMouseup = function (event) {
        if (event.button !== 0 || !this._drag) {
            document.removeEventListener('mousemove', this, true);
            document.removeEventListener('mouseup', this, true);
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    };
    /**
     * Handle the `'mousemove'` event for the widget.
     */
    OutputGutter.prototype._evtMousemove = function (event) {
        event.preventDefault();
        event.stopPropagation();
        // Bail if we are the one dragging.
        if (this._drag) {
            return;
        }
        // Check for a drag initialization.
        var data = this._dragData;
        var dx = Math.abs(event.clientX - data.pressX);
        var dy = Math.abs(event.clientY - data.pressY);
        if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
            return;
        }
        this._startDrag(event.clientX, event.clientY);
    };
    /**
     * Start a drag event.
     */
    OutputGutter.prototype._startDrag = function (clientX, clientY) {
        var _this = this;
        // Set up the drag event.
        this._drag = new dragdrop_1.Drag({
            mimeData: new mimedata_1.MimeData(),
            supportedActions: 'copy',
            proposedAction: 'copy'
        });
        this._drag.mimeData.setData(FACTORY_MIME, function () {
            var outputArea = _this.parent.parent;
            return outputArea.mirror();
        });
        // Remove mousemove and mouseup listeners and start the drag.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        this._drag.start(clientX, clientY).then(function (action) {
            _this._drag = null;
        });
    };
    /**
     * Dispose of the resources held by the widget.
     */
    OutputGutter.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._dragData = null;
        this._drag = null;
        _super.prototype.dispose.call(this);
    };
    return OutputGutter;
}(widget_1.Widget));
exports.OutputGutter = OutputGutter;
/**
 * An output widget.
 */
var OutputWidget = (function (_super) {
    __extends(OutputWidget, _super);
    /**
     * Construct a new output widget.
     */
    function OutputWidget(options) {
        _super.call(this);
        this._rendermime = null;
        this._placeholder = null;
        var layout = new panel_1.PanelLayout();
        this.layout = layout;
        var prompt = new OutputGutter();
        this._placeholder = new widget_1.Widget();
        this.addClass(OUTPUT_CLASS);
        prompt.addClass(PROMPT_CLASS);
        this._placeholder.addClass(RESULT_CLASS);
        layout.addWidget(prompt);
        layout.addWidget(this._placeholder);
        this._rendermime = options.rendermime;
    }
    Object.defineProperty(OutputWidget.prototype, "prompt", {
        /**
         * The prompt widget used by the output widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var layout = this.layout;
            return layout.widgets.at(0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputWidget.prototype, "output", {
        /**
         * The rendered output used by the output widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var layout = this.layout;
            return layout.widgets.at(1);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    OutputWidget.prototype.dispose = function () {
        this._rendermime = null;
        this._placeholder = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Clear the widget contents.
     */
    OutputWidget.prototype.clear = function () {
        this.setOutput(this._placeholder);
        this.prompt.node.textContent = '';
    };
    /**
     * Render an output.
     *
     * @param options - The options used to render the output.
     */
    OutputWidget.prototype.render = function (options) {
        var output = options.output, trusted = options.trusted, injector = options.injector;
        // Handle an input request.
        if (output.output_type === 'input_request') {
            var child_1 = new InputWidget(output);
            this.setOutput(child_1);
            return;
        }
        // Extract the data from the output and sanitize if necessary.
        var rendermime = this._rendermime;
        var bundle = this.getBundle(output);
        var data = this.convertBundle(bundle);
        // Clear the content.
        this.clear();
        // Bail if no data to display.
        if (!data) {
            console.warn('Did not find renderer for output mimebundle.');
            return;
        }
        // Create the output result area.
        var child = rendermime.render({ bundle: data, trusted: trusted, injector: injector });
        if (!child) {
            return;
        }
        this.setOutput(child);
        // Add classes and output prompt as necessary.
        switch (output.output_type) {
            case 'execute_result':
                child.addClass(EXECUTE_CLASS);
                var count = output.execution_count;
                this.prompt.node.textContent = "Out[" + (count === null ? ' ' : count) + "]:";
                break;
            case 'display_data':
                child.addClass(DISPLAY_CLASS);
                break;
            case 'stream':
                if (output.name === 'stdout') {
                    child.addClass(STDOUT_CLASS);
                }
                else {
                    child.addClass(STDERR_CLASS);
                }
                break;
            case 'error':
                child.addClass(ERROR_CLASS);
                break;
            default:
                break;
        }
    };
    /**
     * Set the widget output.
     */
    OutputWidget.prototype.setOutput = function (value) {
        var layout = this.layout;
        var old = this.output;
        value = value || null;
        if (old === value) {
            return;
        }
        if (old) {
            if (old !== this._placeholder) {
                old.dispose();
            }
            else {
                old.parent = null;
            }
        }
        if (value) {
            layout.addWidget(value);
            value.addClass(RESULT_CLASS);
        }
        else {
            layout.addWidget(this._placeholder);
        }
    };
    /**
     * Get the mime bundle for an output.
     *
     * @params output - A kernel output message payload.
     *
     * @returns - A mime bundle for the payload.
     */
    OutputWidget.prototype.getBundle = function (output) {
        var bundle;
        switch (output.output_type) {
            case 'execute_result':
                bundle = output.data;
                break;
            case 'display_data':
                bundle = output.data;
                break;
            case 'stream':
                var text = output.text;
                bundle = {
                    'application/vnd.jupyter.console-text': text
                };
                break;
            case 'error':
                var out = output;
                var traceback = out.traceback.join('\n');
                bundle = {
                    'application/vnd.jupyter.console-text': traceback ||
                        out.ename + ": " + out.evalue
                };
                break;
            default:
                break;
        }
        return bundle || {};
    };
    /**
     * Convert a mime bundle to a mime map.
     */
    OutputWidget.prototype.convertBundle = function (bundle) {
        var map = Object.create(null);
        for (var mimeType in bundle) {
            var value = bundle[mimeType];
            if (Array.isArray(value)) {
                map[mimeType] = value.join('\n');
            }
            else {
                map[mimeType] = value;
            }
        }
        return map;
    };
    return OutputWidget;
}(widget_1.Widget));
exports.OutputWidget = OutputWidget;
/**
 * A widget that handles stdin requests from the kernel.
 */
var InputWidget = (function (_super) {
    __extends(InputWidget, _super);
    /**
     * Construct a new input widget.
     */
    function InputWidget(request) {
        _super.call(this, { node: Private.createInputWidgetNode() });
        this._kernel = null;
        this._input = null;
        this.addClass(STDIN_CLASS);
        var text = this.node.firstChild;
        text.textContent = request.prompt;
        this._input = this.node.lastChild;
        if (request.password) {
            this._input.type = 'password';
        }
        this._kernel = request.kernel;
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    InputWidget.prototype.handleEvent = function (event) {
        var input = this._input;
        if (event.type === 'keydown') {
            if (event.keyCode === 13) {
                this._kernel.sendInputReply({
                    value: input.value
                });
                var rendered = document.createElement('span');
                rendered.className = STDIN_RENDERED_CLASS;
                if (input.type === 'password') {
                    rendered.textContent = Array(input.value.length + 1).join('Â·');
                }
                else {
                    rendered.textContent = input.value;
                }
                this.node.replaceChild(rendered, input);
            }
            // Suppress keydown events from leaving the input.
            event.stopPropagation();
        }
    };
    /**
     * Handle `after-attach` messages sent to the widget.
     */
    InputWidget.prototype.onAfterAttach = function (msg) {
        this._input.addEventListener('keydown', this);
        this.update();
    };
    /**
     * Handle `update-request` messages sent to the widget.
     */
    InputWidget.prototype.onUpdateRequest = function (msg) {
        this._input.focus();
    };
    /**
     * Handle `before-detach` messages sent to the widget.
     */
    InputWidget.prototype.onBeforeDetach = function (msg) {
        this._input.removeEventListener('keydown', this);
    };
    return InputWidget;
}(widget_1.Widget));
// Define the signals for the `OutputAreaWidget` class.
signaling_1.defineSignal(OutputAreaWidget.prototype, 'modelChanged');
signaling_1.defineSignal(OutputAreaWidget.prototype, 'modelDisposed');
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Create the node for an InputWidget.
     */
    function createInputWidgetNode() {
        var node = document.createElement('div');
        var prompt = document.createElement('span');
        prompt.className = STDIN_PROMPT_CLASS;
        var input = document.createElement('input');
        input.className = STDIN_INPUT_CLASS;
        node.appendChild(prompt);
        node.appendChild(input);
        return node;
    }
    Private.createInputWidgetNode = createInputWidgetNode;
})(Private || (Private = {}));
//# sourceMappingURL=widget.js.map