// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var services_1 = require('@jupyterlab/services');
var json_1 = require('phosphor/lib/algorithm/json');
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var signaling_1 = require('phosphor/lib/core/signaling');
var metadata_1 = require('../common/metadata');
var output_area_1 = require('../output-area');
/**
 * An implementation of the cell model.
 */
var CellModel = (function () {
    /**
     * Construct a cell model from optional cell content.
     */
    function CellModel(cell) {
        this._metadata = Object.create(null);
        this._cursors = Object.create(null);
        this._source = '';
        if (!cell) {
            return;
        }
        if (Array.isArray(cell.source)) {
            this.source = cell.source.join('\n');
        }
        else {
            this.source = cell.source;
        }
        var metadata = services_1.utils.copy(cell.metadata);
        if (this.type !== 'raw') {
            delete metadata['format'];
        }
        if (this.type !== 'code') {
            delete metadata['collapsed'];
            delete metadata['scrolled'];
        }
        this._metadata = metadata;
    }
    Object.defineProperty(CellModel.prototype, "source", {
        /**
         * The input content of the cell.
         */
        get: function () {
            return this._source;
        },
        set: function (newValue) {
            if (this._source === newValue) {
                return;
            }
            var oldValue = this._source;
            this._source = newValue;
            this.contentChanged.emit(void 0);
            this.stateChanged.emit({ name: 'source', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellModel.prototype, "isDisposed", {
        /**
         * Get whether the model is disposed.
         */
        get: function () {
            return this._metadata === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    CellModel.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        signaling_1.clearSignalData(this);
        for (var key in this._cursors) {
            this._cursors[key].dispose();
        }
        this._cursors = null;
        this._metadata = null;
    };
    /**
     * Serialize the model to JSON.
     */
    CellModel.prototype.toJSON = function () {
        return {
            cell_type: this.type,
            source: this.source,
            metadata: services_1.utils.copy(this._metadata)
        };
    };
    /**
     * Get a metadata cursor for the cell.
     *
     * #### Notes
     * Metadata associated with the nbformat spec are set directly
     * on the model.  This method is used to interact with a namespaced
     * set of metadata on the cell.
     */
    CellModel.prototype.getMetadata = function (name) {
        var _this = this;
        if (this.isDisposed) {
            return null;
        }
        if (name in this._cursors) {
            return this._cursors[name];
        }
        var cursor = new metadata_1.MetadataCursor(name, function () {
            return _this._metadata[name];
        }, function (value) {
            _this.setCursorData(name, value);
        });
        this._cursors[name] = cursor;
        return cursor;
    };
    /**
     * List the metadata namespace keys for the notebook.
     *
     * #### Notes
     * Metadata associated with the nbformat are not included.
     */
    CellModel.prototype.listMetadata = function () {
        return iteration_1.iter(Object.keys(this._metadata));
    };
    /**
     * Set the cursor data for a given field.
     */
    CellModel.prototype.setCursorData = function (name, newValue) {
        var oldValue = this._metadata[name];
        if (json_1.deepEqual(oldValue, newValue)) {
            return;
        }
        this._metadata[name] = newValue;
        this.contentChanged.emit(void 0);
        this.metadataChanged.emit({ name: name, oldValue: oldValue, newValue: newValue });
    };
    return CellModel;
}());
exports.CellModel = CellModel;
// Define the signals for the `CellModel` class.
signaling_1.defineSignal(CellModel.prototype, 'contentChanged');
signaling_1.defineSignal(CellModel.prototype, 'metadataChanged');
signaling_1.defineSignal(CellModel.prototype, 'stateChanged');
/**
 * An implementation of a raw cell model.
 */
var RawCellModel = (function (_super) {
    __extends(RawCellModel, _super);
    function RawCellModel() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(RawCellModel.prototype, "type", {
        /**
         * The type of the cell.
         */
        get: function () {
            return 'raw';
        },
        enumerable: true,
        configurable: true
    });
    return RawCellModel;
}(CellModel));
exports.RawCellModel = RawCellModel;
/**
 * An implementation of a markdown cell model.
 */
var MarkdownCellModel = (function (_super) {
    __extends(MarkdownCellModel, _super);
    function MarkdownCellModel() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(MarkdownCellModel.prototype, "type", {
        /**
         * The type of the cell.
         */
        get: function () {
            return 'markdown';
        },
        enumerable: true,
        configurable: true
    });
    return MarkdownCellModel;
}(CellModel));
exports.MarkdownCellModel = MarkdownCellModel;
/**
 * An implementation of a code cell Model.
 */
var CodeCellModel = (function (_super) {
    __extends(CodeCellModel, _super);
    /**
     * Construct a new code cell with optional original cell content.
     */
    function CodeCellModel(cell) {
        var _this = this;
        _super.call(this, cell);
        this._outputs = null;
        this._executionCount = null;
        this._outputs = new output_area_1.OutputAreaModel();
        if (cell && cell.cell_type === 'code') {
            this.executionCount = cell.execution_count;
            for (var _i = 0, _a = cell.outputs; _i < _a.length; _i++) {
                var output = _a[_i];
                this._outputs.add(output);
            }
        }
        this._outputs.changed.connect(function () {
            _this.contentChanged.emit(void 0);
        });
    }
    Object.defineProperty(CodeCellModel.prototype, "type", {
        /**
         * The type of the cell.
         */
        get: function () {
            return 'code';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeCellModel.prototype, "executionCount", {
        /**
         * The execution count of the cell.
         */
        get: function () {
            return this._executionCount || null;
        },
        set: function (newValue) {
            if (newValue === this._executionCount) {
                return;
            }
            var oldValue = this.executionCount;
            this._executionCount = newValue || null;
            this.contentChanged.emit(void 0);
            this.stateChanged.emit({ name: 'executionCount', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeCellModel.prototype, "outputs", {
        /**
         * The cell outputs.
         */
        get: function () {
            return this._outputs;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    CodeCellModel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._outputs.dispose();
        this._outputs = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Serialize the model to JSON.
     */
    CodeCellModel.prototype.toJSON = function () {
        var cell = _super.prototype.toJSON.call(this);
        cell.execution_count = this.executionCount || null;
        var outputs = this.outputs;
        cell.outputs = [];
        for (var i = 0; i < outputs.length; i++) {
            var output = outputs.get(i);
            if (output.output_type !== 'input_request') {
                cell.outputs.push(output);
            }
        }
        return cell;
    };
    return CodeCellModel;
}(CellModel));
exports.CodeCellModel = CodeCellModel;
//# sourceMappingURL=model.js.map