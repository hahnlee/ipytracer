// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var observablevector_1 = require('../../common/observablevector');
/**
 * A concrete implementation of an observable undoable vector.
 */
var ObservableUndoableVector = (function (_super) {
    __extends(ObservableUndoableVector, _super);
    /**
     * Construct a new undoable observable vector.
     */
    function ObservableUndoableVector(factory) {
        _super.call(this);
        this._inCompound = false;
        this._isUndoable = true;
        this._madeCompoundChange = false;
        this._index = -1;
        this._stack = [];
        this._factory = null;
        this._factory = factory;
        this.changed.connect(this._onVectorChanged, this);
    }
    Object.defineProperty(ObservableUndoableVector.prototype, "canRedo", {
        /**
         * Whether the object can redo changes.
         */
        get: function () {
            return this._index < this._stack.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableUndoableVector.prototype, "canUndo", {
        /**
         * Whether the object can undo changes.
         */
        get: function () {
            return this._index >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableUndoableVector.prototype, "isDisposed", {
        /**
         * Test whether the vector is disposed.
         */
        get: function () {
            return this._factory === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    ObservableUndoableVector.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._factory = null;
        this._stack = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Begin a compound operation.
     *
     * @param isUndoAble - Whether the operation is undoable.
     *   The default is `true`.
     */
    ObservableUndoableVector.prototype.beginCompoundOperation = function (isUndoAble) {
        this._inCompound = true;
        this._isUndoable = (isUndoAble !== false);
        this._madeCompoundChange = false;
    };
    /**
     * End a compound operation.
     */
    ObservableUndoableVector.prototype.endCompoundOperation = function () {
        this._inCompound = false;
        this._isUndoable = true;
        if (this._madeCompoundChange) {
            this._index++;
        }
    };
    /**
     * Undo an operation.
     */
    ObservableUndoableVector.prototype.undo = function () {
        if (!this.canUndo) {
            return;
        }
        var changes = this._stack[this._index];
        this._isUndoable = false;
        for (var _i = 0, _a = changes.reverse(); _i < _a.length; _i++) {
            var change = _a[_i];
            this._undoChange(change);
        }
        this._isUndoable = true;
        this._index--;
    };
    /**
     * Redo an operation.
     */
    ObservableUndoableVector.prototype.redo = function () {
        if (!this.canRedo) {
            return;
        }
        this._index++;
        var changes = this._stack[this._index];
        this._isUndoable = false;
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            this._redoChange(change);
        }
        this._isUndoable = true;
    };
    /**
     * Clear the change stack.
     */
    ObservableUndoableVector.prototype.clearUndo = function () {
        this._index = -1;
        this._stack = [];
    };
    /**
     * Handle a change in the vector.
     */
    ObservableUndoableVector.prototype._onVectorChanged = function (list, change) {
        if (this.isDisposed || !this._isUndoable) {
            return;
        }
        // Clear everything after this position if necessary.
        if (!this._inCompound || !this._madeCompoundChange) {
            this._stack = this._stack.slice(0, this._index + 1);
        }
        // Copy the change.
        var evt = this._copyChange(change);
        // Put the change in the stack.
        if (this._stack[this._index + 1]) {
            this._stack[this._index + 1].push(evt);
        }
        else {
            this._stack.push([evt]);
        }
        // If not in a compound operation, increase index.
        if (!this._inCompound) {
            this._index++;
        }
        else {
            this._madeCompoundChange = true;
        }
    };
    /**
     * Undo a change event.
     */
    ObservableUndoableVector.prototype._undoChange = function (change) {
        var _this = this;
        var index = 0;
        var factory = this._factory;
        switch (change.type) {
            case 'add':
                iteration_1.each(change.newValues, function () {
                    _this.removeAt(change.newIndex);
                });
                break;
            case 'set':
                index = change.oldIndex;
                iteration_1.each(change.oldValues, function (value) {
                    _this.set(index++, factory(value));
                });
                break;
            case 'remove':
                index = change.oldIndex;
                iteration_1.each(change.oldValues, function (value) {
                    _this.insert(index++, factory(value));
                });
                break;
            case 'move':
                this.move(change.newIndex, change.oldIndex);
                break;
            default:
                return;
        }
    };
    /**
     * Redo a change event.
     */
    ObservableUndoableVector.prototype._redoChange = function (change) {
        var _this = this;
        var index = 0;
        var factory = this._factory;
        switch (change.type) {
            case 'add':
                index = change.newIndex;
                iteration_1.each(change.newValues, function (value) {
                    _this.insert(index++, factory(value));
                });
                break;
            case 'set':
                index = change.newIndex;
                iteration_1.each(change.newValues, function (value) {
                    _this.set(change.newIndex++, factory(value));
                });
                break;
            case 'remove':
                iteration_1.each(change.oldValues, function () {
                    _this.removeAt(change.oldIndex);
                });
                break;
            case 'move':
                this.move(change.oldIndex, change.newIndex);
                break;
            default:
                return;
        }
    };
    /**
     * Copy a change as JSON.
     */
    ObservableUndoableVector.prototype._copyChange = function (change) {
        var oldValues = [];
        iteration_1.each(change.oldValues, function (value) {
            oldValues.push(value.toJSON());
        });
        var newValues = [];
        iteration_1.each(change.newValues, function (value) {
            newValues.push(value.toJSON());
        });
        return {
            type: change.type,
            oldIndex: change.oldIndex,
            newIndex: change.newIndex,
            oldValues: oldValues,
            newValues: newValues
        };
    };
    return ObservableUndoableVector;
}(observablevector_1.ObservableVector));
exports.ObservableUndoableVector = ObservableUndoableVector;
//# sourceMappingURL=undo.js.map