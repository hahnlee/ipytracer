"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var mutation_1 = require('../algorithm/mutation');
var vector_1 = require('../collections/vector');
var messaging_1 = require('../core/messaging');
var properties_1 = require('../core/properties');
var platform_1 = require('../dom/platform');
var sizing_1 = require('../dom/sizing');
var boxengine_1 = require('./boxengine');
var panel_1 = require('./panel');
var widget_1 = require('./widget');
/**
 * The class name added to BoxPanel instances.
 */
var BOX_PANEL_CLASS = 'p-BoxPanel';
/**
 * The class name added to a BoxPanel child.
 */
var CHILD_CLASS = 'p-BoxPanel-child';
/**
 * The class name added to left-to-right box layout parents.
 */
var LEFT_TO_RIGHT_CLASS = 'p-mod-left-to-right';
/**
 * The class name added to right-to-left box layout parents.
 */
var RIGHT_TO_LEFT_CLASS = 'p-mod-right-to-left';
/**
 * The class name added to top-to-bottom box layout parents.
 */
var TOP_TO_BOTTOM_CLASS = 'p-mod-top-to-bottom';
/**
 * The class name added to bottom-to-top box layout parents.
 */
var BOTTOM_TO_TOP_CLASS = 'p-mod-bottom-to-top';
/**
 * A panel which arranges its widgets in a single row or column.
 *
 * #### Notes
 * This class provides a convenience wrapper around a [[BoxLayout]].
 */
var BoxPanel = (function (_super) {
    __extends(BoxPanel, _super);
    /**
     * Construct a new box panel.
     *
     * @param options - The options for initializing the box panel.
     */
    function BoxPanel(options) {
        if (options === void 0) { options = {}; }
        _super.call(this, { layout: Private.createLayout(options) });
        this.addClass(BOX_PANEL_CLASS);
    }
    Object.defineProperty(BoxPanel.prototype, "direction", {
        /**
         * Get the layout direction for the box panel.
         */
        get: function () {
            return this.layout.direction;
        },
        /**
         * Set the layout direction for the box panel.
         */
        set: function (value) {
            this.layout.direction = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoxPanel.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the box panel.
         */
        get: function () {
            return this.layout.spacing;
        },
        /**
         * Set the inter-element spacing for the box panel.
         */
        set: function (value) {
            this.layout.spacing = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * A message handler invoked on a `'child-added'` message.
     */
    BoxPanel.prototype.onChildAdded = function (msg) {
        msg.child.addClass(CHILD_CLASS);
    };
    /**
     * A message handler invoked on a `'child-removed'` message.
     */
    BoxPanel.prototype.onChildRemoved = function (msg) {
        msg.child.removeClass(CHILD_CLASS);
    };
    return BoxPanel;
}(panel_1.Panel));
exports.BoxPanel = BoxPanel;
/**
 * The namespace for the `BoxPanel` class statics.
 */
var BoxPanel;
(function (BoxPanel) {
    /**
     * Get the box panel stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box panel stretch factor for the widget.
     */
    function getStretch(widget) {
        return BoxLayout.getStretch(widget);
    }
    BoxPanel.getStretch = getStretch;
    /**
     * Set the box panel stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        BoxLayout.setStretch(widget, value);
    }
    BoxPanel.setStretch = setStretch;
    /**
     * Get the box panel size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box panel size basis for the widget.
     */
    function getSizeBasis(widget) {
        return BoxLayout.getSizeBasis(widget);
    }
    BoxPanel.getSizeBasis = getSizeBasis;
    /**
     * Set the box panel size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the size basis.
     */
    function setSizeBasis(widget, value) {
        BoxLayout.setSizeBasis(widget, value);
    }
    BoxPanel.setSizeBasis = setSizeBasis;
})(BoxPanel = exports.BoxPanel || (exports.BoxPanel = {}));
/**
 * A layout which arranges its widgets in a single row or column.
 */
var BoxLayout = (function (_super) {
    __extends(BoxLayout, _super);
    /**
     * Construct a new box layout.
     *
     * @param options - The options for initializing the layout.
     */
    function BoxLayout(options) {
        if (options === void 0) { options = {}; }
        _super.call(this);
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._box = null;
        this._sizers = new vector_1.Vector();
        this._direction = 'top-to-bottom';
        if (options.direction !== void 0) {
            this._direction = options.direction;
        }
        if (options.spacing !== void 0) {
            this._spacing = Private.clampSpacing(options.spacing);
        }
    }
    Object.defineProperty(BoxLayout.prototype, "direction", {
        /**
         * Get the layout direction for the box layout.
         */
        get: function () {
            return this._direction;
        },
        /**
         * Set the layout direction for the box layout.
         */
        set: function (value) {
            if (this._direction === value) {
                return;
            }
            this._direction = value;
            if (!this.parent) {
                return;
            }
            Private.toggleDirection(this.parent, value);
            this.parent.fit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoxLayout.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the box layout.
         */
        get: function () {
            return this._spacing;
        },
        /**
         * Set the inter-element spacing for the box layout.
         */
        set: function (value) {
            value = Private.clampSpacing(value);
            if (this._spacing === value) {
                return;
            }
            this._spacing = value;
            if (!this.parent) {
                return;
            }
            this.parent.fit();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Perform layout initialization which requires the parent widget.
     */
    BoxLayout.prototype.init = function () {
        Private.toggleDirection(this.parent, this.direction);
        _super.prototype.init.call(this);
    };
    /**
     * Attach a widget to the parent's DOM node.
     *
     * @param index - The current index of the widget in the layout.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    BoxLayout.prototype.attachWidget = function (index, widget) {
        // Create and add a new sizer for the widget.
        this._sizers.insert(index, new boxengine_1.BoxSizer());
        // Prepare the layout geometry for the widget.
        widget_1.Widget.prepareGeometry(widget);
        // Add the widget's node to the parent.
        this.parent.node.appendChild(widget.node);
        // Send an `'after-attach'` message if the parent is attached.
        if (this.parent.isAttached)
            messaging_1.sendMessage(widget, widget_1.WidgetMessage.AfterAttach);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Move a widget in the parent's DOM node.
     *
     * @param fromIndex - The previous index of the widget in the layout.
     *
     * @param toIndex - The current index of the widget in the layout.
     *
     * @param widget - The widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    BoxLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {
        // Move the sizer for the widget.
        mutation_1.move(this._sizers, fromIndex, toIndex);
        // Post an update request for the parent widget.
        this.parent.update();
    };
    /**
     * Detach a widget from the parent's DOM node.
     *
     * @param index - The previous index of the widget in the layout.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    BoxLayout.prototype.detachWidget = function (index, widget) {
        // Remove the sizer for the widget.
        this._sizers.removeAt(index);
        // Send a `'before-detach'` message if the parent is attached.
        if (this.parent.isAttached)
            messaging_1.sendMessage(widget, widget_1.WidgetMessage.BeforeDetach);
        // Remove the widget's node from the parent.
        this.parent.node.removeChild(widget.node);
        // Reset the layout geometry for the widget.
        widget_1.Widget.resetGeometry(widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    BoxLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    BoxLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    BoxLayout.prototype.onChildShown = function (msg) {
        if (platform_1.IS_IE || platform_1.IS_EDGE) {
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.FitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    BoxLayout.prototype.onChildHidden = function (msg) {
        if (platform_1.IS_IE || platform_1.IS_EDGE) {
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.FitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    BoxLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            this._update(msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    BoxLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            this._update(-1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    BoxLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            this._fit();
        }
    };
    /**
     * Fit the layout to the total size required by the widgets.
     */
    BoxLayout.prototype._fit = function () {
        // Compute the visible item count.
        var nVisible = 0;
        var widgets = this.widgets;
        for (var i = 0, n = widgets.length; i < n; ++i) {
            if (!widgets.at(i).isHidden)
                nVisible++;
        }
        // Update the fixed space for the visible items.
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        // Setup the initial size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        var horz = Private.isHorizontal(this._direction);
        if (horz) {
            minW = this._fixed;
            maxW = nVisible > 0 ? minW : maxW;
        }
        else {
            minH = this._fixed;
            maxH = nVisible > 0 ? minH : maxH;
        }
        // Update the sizers and computed size limits.
        for (var i = 0, n = widgets.length; i < n; ++i) {
            var widget = widgets.at(i);
            var sizer = this._sizers.at(i);
            if (widget.isHidden) {
                sizer.minSize = 0;
                sizer.maxSize = 0;
                continue;
            }
            var limits = sizing_1.sizeLimits(widget.node);
            sizer.sizeHint = BoxLayout.getSizeBasis(widget);
            sizer.stretch = BoxLayout.getStretch(widget);
            if (horz) {
                sizer.minSize = limits.minWidth;
                sizer.maxSize = limits.maxWidth;
                minW += limits.minWidth;
                maxW += limits.maxWidth;
                minH = Math.max(minH, limits.minHeight);
                maxH = Math.min(maxH, limits.maxHeight);
            }
            else {
                sizer.minSize = limits.minHeight;
                sizer.maxSize = limits.maxHeight;
                minH += limits.minHeight;
                maxH += limits.maxHeight;
                minW = Math.max(minW, limits.minWidth);
                maxW = Math.min(maxW, limits.maxWidth);
            }
        }
        // Update the box sizing and add it to the size constraints.
        var box = this._box = sizing_1.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the parent's size constraints.
        var style = this.parent.node.style;
        style.minWidth = minW + "px";
        style.minHeight = minH + "px";
        style.maxWidth = maxW === Infinity ? 'none' : maxW + "px";
        style.maxHeight = maxH === Infinity ? 'none' : maxH + "px";
        // Set the dirty flag to ensure only a single update occurs.
        this._dirty = true;
        // Notify the ancestor that it should fit immediately. This may
        // cause a resize of the parent, fulfilling the required update.
        var ancestor = this.parent.parent;
        if (ancestor)
            messaging_1.sendMessage(ancestor, widget_1.WidgetMessage.FitRequest);
        // If the dirty flag is still set, the parent was not resized.
        // Trigger the required update on the parent widget immediately.
        if (this._dirty)
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.UpdateRequest);
    };
    /**
     * Update the layout position and size of the widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    BoxLayout.prototype._update = function (offsetWidth, offsetHeight) {
        // Clear the dirty flag to indicate the update occurred.
        this._dirty = false;
        // Bail early if there are no widgets to layout.
        var widgets = this.widgets;
        if (widgets.length === 0) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = this.parent.node.offsetHeight;
        }
        // Ensure the parent box sizing data is computed.
        var box = this._box || (this._box = sizing_1.boxSizing(this.parent.node));
        // Compute the layout area adjusted for border and padding.
        var top = box.paddingTop;
        var left = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Distribute the layout space and adjust the start position.
        switch (this._direction) {
            case 'left-to-right':
                boxengine_1.boxCalc(this._sizers, Math.max(0, width - this._fixed));
                break;
            case 'top-to-bottom':
                boxengine_1.boxCalc(this._sizers, Math.max(0, height - this._fixed));
                break;
            case 'right-to-left':
                boxengine_1.boxCalc(this._sizers, Math.max(0, width - this._fixed));
                left += width;
                break;
            case 'bottom-to-top':
                boxengine_1.boxCalc(this._sizers, Math.max(0, height - this._fixed));
                top += height;
                break;
        }
        // Layout the widgets using the computed box sizes.
        for (var i = 0, n = widgets.length; i < n; ++i) {
            var widget = widgets.at(i);
            if (widget.isHidden) {
                continue;
            }
            var size = this._sizers.at(i).size;
            switch (this._direction) {
                case 'left-to-right':
                    widget_1.Widget.setGeometry(widget, left, top, size, height);
                    left += size + this._spacing;
                    break;
                case 'top-to-bottom':
                    widget_1.Widget.setGeometry(widget, left, top, width, size);
                    top += size + this._spacing;
                    break;
                case 'right-to-left':
                    widget_1.Widget.setGeometry(widget, left - size, top, size, height);
                    left -= size + this._spacing;
                    break;
                case 'bottom-to-top':
                    widget_1.Widget.setGeometry(widget, left, top - size, width, size);
                    top -= size + this._spacing;
                    break;
            }
        }
    };
    return BoxLayout;
}(panel_1.PanelLayout));
exports.BoxLayout = BoxLayout;
/**
 * The namespace for the `BoxLayout` class statics.
 */
var BoxLayout;
(function (BoxLayout) {
    /**
     * Get the box layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box layout stretch factor for the widget.
     */
    function getStretch(widget) {
        return Private.stretchProperty.get(widget);
    }
    BoxLayout.getStretch = getStretch;
    /**
     * Set the box layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        Private.stretchProperty.set(widget, value);
    }
    BoxLayout.setStretch = setStretch;
    /**
     * Get the box layout size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box layout size basis for the widget.
     */
    function getSizeBasis(widget) {
        return Private.sizeBasisProperty.get(widget);
    }
    BoxLayout.getSizeBasis = getSizeBasis;
    /**
     * Set the box layout size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the size basis.
     */
    function setSizeBasis(widget, value) {
        Private.sizeBasisProperty.set(widget, value);
    }
    BoxLayout.setSizeBasis = setSizeBasis;
})(BoxLayout = exports.BoxLayout || (exports.BoxLayout = {}));
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * The property descriptor for a widget stretch factor.
     */
    Private.stretchProperty = new properties_1.AttachedProperty({
        name: 'stretch',
        value: 0,
        coerce: function (owner, value) { return Math.max(0, Math.floor(value)); },
        changed: onChildPropertyChanged
    });
    /**
     * The property descriptor for a widget size basis.
     */
    Private.sizeBasisProperty = new properties_1.AttachedProperty({
        name: 'sizeBasis',
        value: 0,
        coerce: function (owner, value) { return Math.max(0, Math.floor(value)); },
        changed: onChildPropertyChanged
    });
    /**
     * Create a box layout for the given panel options.
     */
    function createLayout(options) {
        return options.layout || new BoxLayout(options);
    }
    Private.createLayout = createLayout;
    /**
     * Test whether a direction has horizontal orientation.
     */
    function isHorizontal(dir) {
        return dir === 'left-to-right' || dir === 'right-to-left';
    }
    Private.isHorizontal = isHorizontal;
    /**
     * Toggle the CSS direction class for the given widget.
     */
    function toggleDirection(widget, dir) {
        widget.toggleClass(LEFT_TO_RIGHT_CLASS, dir === 'left-to-right');
        widget.toggleClass(RIGHT_TO_LEFT_CLASS, dir === 'right-to-left');
        widget.toggleClass(TOP_TO_BOTTOM_CLASS, dir === 'top-to-bottom');
        widget.toggleClass(BOTTOM_TO_TOP_CLASS, dir === 'bottom-to-top');
    }
    Private.toggleDirection = toggleDirection;
    /**
     * Clamp a spacing value to an integer >= 0.
     */
    function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
    }
    Private.clampSpacing = clampSpacing;
    /**
     * The change handler for the attached child properties.
     */
    function onChildPropertyChanged(child) {
        var parent = child.parent;
        var layout = parent && parent.layout;
        if (layout instanceof BoxLayout)
            parent.fit();
    }
})(Private || (Private = {}));
