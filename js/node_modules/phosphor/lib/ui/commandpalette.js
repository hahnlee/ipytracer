"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var searching_1 = require('../algorithm/searching');
var vector_1 = require('../collections/vector');
var query_1 = require('../dom/query');
var keymap_1 = require('./keymap');
var widget_1 = require('./widget');
/**
 * The class name added to `CommandPalette` instances.
 */
var PALETTE_CLASS = 'p-CommandPalette';
/**
 * The class name added to the search section of the palette.
 */
var SEARCH_CLASS = 'p-CommandPalette-search';
/**
 * The class name added to the input wrapper in the search section.
 */
var WRAPPER_CLASS = 'p-CommandPalette-wrapper';
/**
 * The class name added to the input node in the search section.
 */
var INPUT_CLASS = 'p-CommandPalette-input';
/**
 * The class name added to the content section of the palette.
 */
var CONTENT_CLASS = 'p-CommandPalette-content';
/**
 * The class name added to a palette section header.
 */
var HEADER_CLASS = 'p-CommandPalette-header';
/**
 * The class name added to a palette item node.
 */
var ITEM_CLASS = 'p-CommandPalette-item';
/**
 * The class name added to a item label node.
 */
var LABEL_CLASS = 'p-CommandPalette-itemLabel';
/**
 * The class name added to a item shortcut node.
 */
var SHORTCUT_CLASS = 'p-CommandPalette-itemShortcut';
/**
 * The class name added to a item caption node.
 */
var CAPTION_CLASS = 'p-CommandPalette-itemCaption';
/**
 * The class name added to the active palette header or item.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * The class name added to a disabled command item.
 */
var DISABLED_CLASS = 'p-mod-disabled';
/**
 * The class name added to a toggled command item.
 */
var TOGGLED_CLASS = 'p-mod-toggled';
/**
 * A widget which displays command items as a searchable palette.
 */
var CommandPalette = (function (_super) {
    __extends(CommandPalette, _super);
    /**
     * Construct a new command palette.
     *
     * @param options - The options for initializing the palette.
     */
    function CommandPalette(options) {
        _super.call(this, { node: Private.createNode() });
        this._activeIndex = 1;
        this._itemNodes = new vector_1.Vector();
        this._headerNodes = new vector_1.Vector();
        this._items = new vector_1.Vector();
        this._result = null;
        this.addClass(PALETTE_CLASS);
        this.setFlag(widget_1.WidgetFlag.DisallowLayout);
        this._keymap = options.keymap;
        this._commands = options.commands;
        this._renderer = options.renderer || CommandPalette.defaultRenderer;
        this._commands.commandChanged.connect(this._onGenericChange, this);
        this._keymap.bindingChanged.connect(this._onGenericChange, this);
    }
    /**
     * Dispose of the resources held by the command palette.
     */
    CommandPalette.prototype.dispose = function () {
        this._items.clear();
        this._itemNodes.clear();
        this._headerNodes.clear();
        this._result = null;
        this._keymap = null;
        this._commands = null;
        this._renderer = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(CommandPalette.prototype, "searchNode", {
        /**
         * Get the command palette search node.
         *
         * #### Notes
         * This is the node which contains the search-related elements.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(SEARCH_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPalette.prototype, "inputNode", {
        /**
         * Get the command palette input node.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(INPUT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPalette.prototype, "contentNode", {
        /**
         * Get the command palette content node.
         *
         * #### Notes
         * This is the node which holds the command item nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPalette.prototype, "items", {
        /**
         * A read-only sequence of the command items in the palette.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPalette.prototype, "commands", {
        /**
         * The command registry used by the command palette.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._commands;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPalette.prototype, "keymap", {
        /**
         * The keymap used by the command palette.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._keymap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPalette.prototype, "renderer", {
        /**
         * The renderer used by the command palette.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a command item to the command palette.
     *
     * @param options - The options for creating the command item.
     *
     * @returns The command item added to the palette.
     */
    CommandPalette.prototype.addItem = function (options) {
        // Create a new command item for the options.
        var item = Private.createItem(this._commands, this._keymap, options);
        // Add the item to the vector.
        this._items.pushBack(item);
        // Schedule an update of the content.
        if (this.isAttached)
            this.update();
        // Return the item added to the palette.
        return item;
    };
    /**
     * Remove an item from the command palette.
     *
     * @param item - The item to remove from the palette.
     *
     * @returns The index occupied by the item, or `-1` if the item
     *   was not contained in the menu.
     */
    CommandPalette.prototype.removeItem = function (item) {
        var index = searching_1.indexOf(this._items, item);
        if (index !== -1)
            this.removeItemAt(index);
        return index;
    };
    /**
     * Remove the item at a given index from the command palette.
     *
     * @param index - The index of the item to remove.
     *
     * @returns The item occupying the index, or `null` if the index
     *   is out of range.
     */
    CommandPalette.prototype.removeItemAt = function (index) {
        // Bail if the index is out of range.
        var i = Math.floor(index);
        if (i < 0 || i >= this._items.length) {
            return null;
        }
        // Remove the item from the vector.
        var item = this._items.removeAt(index);
        // Schedule an update of the content.
        if (this.isAttached)
            this.update();
        // Return the removed item.
        return item;
    };
    /**
     * Remove all command items from the command palette.
     */
    CommandPalette.prototype.clearItems = function () {
        // Clear the vector of items.
        this._items.clear();
        // Schedule an update of the content.
        if (this.isAttached)
            this.update();
    };
    /**
     * Handle the DOM events for the command palette.
     *
     * @param event - The DOM event sent to the command palette.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the command palette's DOM node.
     * It should not be called directly by user code.
     */
    CommandPalette.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'input':
                this.update();
                break;
        }
    };
    /**
     * A message handler invoked on a `'after-attach'` message.
     */
    CommandPalette.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('keydown', this);
        this.node.addEventListener('input', this);
        this.update();
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    CommandPalette.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('keydown', this);
        this.node.removeEventListener('input', this);
    };
    /**
     * A message handler invoked on an `'activate-request'` message.
     */
    CommandPalette.prototype.onActivateRequest = function (msg) {
        if (this.isAttached) {
            var input = this.inputNode;
            input.focus();
            input.select();
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    CommandPalette.prototype.onUpdateRequest = function (msg) {
        var _this = this;
        // Clear the current content.
        this.contentNode.textContent = '';
        // Reset the active index and search result.
        this._activeIndex = -1;
        this._result = null;
        // Bail early if there are no command items.
        if (this._items.isEmpty) {
            return;
        }
        // Split the query text into its category and text parts.
        var _a = CommandPalette.splitQuery(this.inputNode.value), category = _a.category, text = _a.text;
        // Search the command items for query matches.
        var result = this._result = Private.search(this._items, category, text);
        // If the result is empty, there is nothing left to do.
        if (result.parts.length === 0) {
            return;
        }
        // Fetch command variables.
        var renderer = this._renderer;
        var itemNodes = this._itemNodes;
        var headerNodes = this._headerNodes;
        // Ensure there are enough header nodes.
        while (headerNodes.length < result.headerCount) {
            headerNodes.pushBack(renderer.createHeaderNode());
        }
        // Ensure there are enough item nodes.
        while (itemNodes.length < result.itemCount) {
            itemNodes.pushBack(renderer.createItemNode());
        }
        // Setup the index counters and document fragment.
        var itemIndex = 0;
        var headerIndex = 0;
        var fragment = document.createDocumentFragment();
        // Render the search result into the fragment.
        for (var _i = 0, _b = result.parts; _i < _b.length; _i++) {
            var part = _b[_i];
            var node = void 0;
            if (part.item === null) {
                node = headerNodes.at(headerIndex++);
                renderer.updateHeaderNode(node, part.markup);
            }
            else {
                node = itemNodes.at(itemIndex++);
                renderer.updateItemNode(node, part.item, part.markup);
            }
            fragment.appendChild(node);
        }
        // Add the fragment to the content node.
        this.contentNode.appendChild(fragment);
        // If there is query text, activate the first command item.
        // Otherwise, reset the content scroll position to the top.
        if (category || text) {
            this._activateNext('item');
        }
        else {
            requestAnimationFrame(function () { _this.contentNode.scrollTop = 0; });
        }
    };
    /**
     * Handle the `'click'` event for the command palette.
     */
    CommandPalette.prototype._evtClick = function (event) {
        // Bail if the click is not the left button.
        if (event.button !== 0) {
            return;
        }
        // Bail if the click was not on a content item.
        var target = event.target;
        var children = this.contentNode.children;
        var i = searching_1.findIndex(children, function (child) { return child.contains(target); });
        if (i === -1) {
            return;
        }
        // Kill the event when a content item is clicked.
        event.preventDefault();
        event.stopPropagation();
        // Bail if there is no search result.
        if (!this._result) {
            return;
        }
        // Bail if the index is out of range.
        var part = this._result.parts[i];
        if (!part) {
            return;
        }
        // Bail if the part has a disabled item.
        if (part.item && !part.item.isEnabled) {
            return;
        }
        // Activate the index and trigger the part.
        this._activate(i);
        this._triggerActive();
    };
    /**
     * Handle the `'keydown'` event for the command palette.
     */
    CommandPalette.prototype._evtKeyDown = function (event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
            return;
        }
        switch (event.keyCode) {
            case 13:
                event.preventDefault();
                event.stopPropagation();
                this._triggerActive();
                break;
            case 38:
                event.preventDefault();
                event.stopPropagation();
                this._activatePrev('any');
                break;
            case 40:
                event.preventDefault();
                event.stopPropagation();
                this._activateNext('any');
                break;
        }
    };
    /**
     * Activate the node at the given render index.
     *
     * If the node is scrolled out of view, it will be scrolled into
     * view and aligned according to the `alignTop` parameter.
     */
    CommandPalette.prototype._activate = function (index) {
        // Fetch common variables.
        var content = this.contentNode;
        var children = content.children;
        // Ensure the index is valid.
        if (index < 0 || index >= children.length) {
            index = -1;
        }
        // Bail if there is no effective change.
        if (this._activeIndex === index) {
            return;
        }
        // Look up the relevant nodes.
        var oldNode = children[this._activeIndex];
        var newNode = children[index];
        // Update the internal active index.
        this._activeIndex = index;
        // Deactivate the old node.
        if (oldNode) {
            oldNode.classList.remove(ACTIVE_CLASS);
        }
        // Activate the new node and scroll it into view.
        if (newNode) {
            newNode.classList.add(ACTIVE_CLASS);
            requestAnimationFrame(function () {
                query_1.scrollIntoViewIfNeeded(content, newNode);
            });
        }
    };
    /**
     * Activate the next enabled index of the given kind.
     */
    CommandPalette.prototype._activateNext = function (kind) {
        // Bail if there are no current search results.
        if (!this._result) {
            return;
        }
        // Bail if the search results are empty.
        var parts = this._result.parts;
        if (parts.length === 0) {
            return;
        }
        // Activate the next enabled index of the specified kind.
        var start = this._activeIndex + 1;
        for (var i = 0, n = parts.length; i < n; ++i) {
            var k = (start + i) % n;
            var item = parts[k].item;
            if (kind === 'item' && item && item.isEnabled) {
                this._activate(k);
                return;
            }
            if (kind === 'header' && !item) {
                this._activate(k);
                return;
            }
            if (kind === 'any' && (!item || item.isEnabled)) {
                this._activate(k);
                return;
            }
        }
        // Otherwise, deactivate the current item.
        this._activate(-1);
    };
    /**
     * Activate the previous enabled index of the given kind.
     */
    CommandPalette.prototype._activatePrev = function (kind) {
        // Bail if there are no current search results.
        if (!this._result) {
            return;
        }
        // Bail if the search results are empty.
        var parts = this._result.parts;
        if (parts.length === 0) {
            return;
        }
        // Activate the previous enabled index of the specified kind.
        var ai = this._activeIndex;
        var start = ai <= 0 ? parts.length - 1 : ai - 1;
        for (var i = 0, n = parts.length; i < n; ++i) {
            var k = (start - i + n) % n;
            var item = parts[k].item;
            if (kind === 'item' && item && item.isEnabled) {
                this._activate(k);
                return;
            }
            if (kind === 'header' && !item) {
                this._activate(k);
                return;
            }
            if (kind === 'any' && (!item || item.isEnabled)) {
                this._activate(k);
                return;
            }
        }
        // Otherwise, deactivate the current item.
        this._activate(-1);
    };
    /**
     * Trigger the result part at the active index.
     *
     * If the part is an enabled command it will be executed. If the
     * part is a header, the category search term will be toggled.
     */
    CommandPalette.prototype._triggerActive = function () {
        // Bail if there is no search result.
        if (!this._result) {
            return;
        }
        // Bail if the active index is out of range.
        var part = this._result.parts[this._activeIndex];
        if (!part) {
            return;
        }
        // Bail if the part has a disabled item.
        if (part.item && !part.item.isEnabled) {
            return;
        }
        // Look up the input node.
        var input = this.inputNode;
        // If the part has an item, focus the input field, select the
        // text, and execute the command.
        if (part.item) {
            input.focus();
            input.select();
            this._commands.execute(part.item.command, part.item.args);
            return;
        }
        // Otherwise, toggle the category text...
        // Parse the current input value.
        var _a = CommandPalette.splitQuery(input.value), category = _a.category, text = _a.text;
        // Extract the raw category text.
        var desired = part.markup.replace(/<mark>|<\/mark>/g, '');
        // Create a new query with the toggled category.
        var computed = desired === category ? '' : desired;
        var query = CommandPalette.joinQuery(computed, text);
        // Update the input text and refocus the field.
        input.value = query;
        input.focus();
        // Schedule an update to render the new search results.
        this.update();
    };
    /**
     * A signal handler for commands and keymap changes.
     */
    CommandPalette.prototype._onGenericChange = function () {
        if (this.isAttached)
            this.update();
    };
    return CommandPalette;
}(widget_1.Widget));
exports.CommandPalette = CommandPalette;
/**
 * The namespace for the `CommandPalette` class statics.
 */
var CommandPalette;
(function (CommandPalette) {
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create a node for a section header.
         *
         * @returns A new node for a section header.
         */
        Renderer.prototype.createHeaderNode = function () {
            var node = document.createElement('li');
            node.className = HEADER_CLASS;
            return node;
        };
        /**
         * Create a node for a command item.
         *
         * @returns A new node for a command item.
         */
        Renderer.prototype.createItemNode = function () {
            var node = document.createElement('li');
            var label = document.createElement('div');
            var caption = document.createElement('div');
            var shortcut = document.createElement('div');
            node.className = ITEM_CLASS;
            label.className = LABEL_CLASS;
            caption.className = CAPTION_CLASS;
            shortcut.className = SHORTCUT_CLASS;
            node.appendChild(shortcut); // will float: right
            node.appendChild(label);
            node.appendChild(caption);
            return node;
        };
        /**
         * Update a header node to reflect the given data.
         *
         * @param node - A node created by a call to `createHeaderNode`.
         *
         * @param markup - The markup for the header text. This is the
         *   section category text interpolated with `<mark>` tags for
         *   the matching search characters.
         */
        Renderer.prototype.updateHeaderNode = function (node, markup) {
            node.className = HEADER_CLASS;
            node.innerHTML = markup;
        };
        /**
         * Update an item node to reflect the state of a command item.
         *
         * @param node - A node created by a call to `createItemNode`.
         *
         * @param item - The command item holding the data for the node.
         *
         * @param markup - The markup for the item label. This is the
         *   item label text interpolated with `<mark>` tags for the
         *   matching search characters.
         */
        Renderer.prototype.updateItemNode = function (node, item, markup) {
            // Setup the initial item class.
            var itemClass = ITEM_CLASS;
            // Add the boolean states to the item class.
            //
            // Note: non-visible items are not rendered by the palette, so
            // there is no need to check the visibility flag of the item.
            if (!item.isEnabled) {
                itemClass += " " + DISABLED_CLASS;
            }
            if (item.isToggled) {
                itemClass += " " + TOGGLED_CLASS;
            }
            // Add the extra class name(s) to the item class.
            var extraItemClass = item.className;
            if (extraItemClass) {
                itemClass += " " + extraItemClass;
            }
            // Generate the formatted shortcut text.
            var shortcutText = this.formatShortcut(item.keyBinding);
            // Extract the relevant child nodes.
            var shortcut = node.firstChild;
            var label = shortcut.nextSibling;
            var caption = label.nextSibling;
            // Set the command ID in the data set.
            node.dataset['command'] = item.command;
            // Update the rest of the node state.
            node.className = itemClass;
            label.innerHTML = markup;
            caption.textContent = item.caption;
            shortcut.textContent = shortcutText;
        };
        /**
         * Format a key binding into shortcut text for display.
         *
         * @param binding - The key binding to format. This may be `null`.
         *
         * @returns The formatted shortcut text for display.
         */
        Renderer.prototype.formatShortcut = function (binding) {
            return binding ? binding.keys.map(keymap_1.Keymap.formatKeystroke).join(' ') : '';
        };
        return Renderer;
    }());
    CommandPalette.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    CommandPalette.defaultRenderer = new Renderer();
    /**
     * Split a query string into its category and text components.
     *
     * @param query - A query string of the form `(:<category>:)?<text>`.
     *
     * @returns The `category` and `text` components of the query with
     *   leading and trailing whitespace removed.
     */
    function splitQuery(query) {
        query = query.trim();
        var i = query.indexOf(':');
        if (i === -1) {
            return { category: '', text: query };
        }
        var category = query.slice(0, i).trim();
        var text = query.slice(i + 1).trim();
        return { category: category, text: text };
    }
    CommandPalette.splitQuery = splitQuery;
    /**
     * Join category and text components into a query string.
     *
     * @param category - The category for the query or an empty string.
     *
     * @param text - The text for the query or an empty string.
     *
     * @returns The joined query string for the components.
     */
    function joinQuery(category, text) {
        var query;
        if (category && text) {
            query = category.trim() + ": " + text.trim();
        }
        else if (category) {
            query = category.trim() + ": ";
        }
        else if (text) {
            query = text.trim();
        }
        else {
            query = '';
        }
        return query;
    }
    CommandPalette.joinQuery = joinQuery;
})(CommandPalette = exports.CommandPalette || (exports.CommandPalette = {}));
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create the DOM node for a command palette.
     */
    function createNode() {
        var node = document.createElement('div');
        var search = document.createElement('div');
        var wrapper = document.createElement('div');
        var input = document.createElement('input');
        var content = document.createElement('ul');
        search.className = SEARCH_CLASS;
        wrapper.className = WRAPPER_CLASS;
        input.className = INPUT_CLASS;
        content.className = CONTENT_CLASS;
        input.spellcheck = false;
        wrapper.appendChild(input);
        search.appendChild(wrapper);
        node.appendChild(search);
        node.appendChild(content);
        return node;
    }
    Private.createNode = createNode;
    /**
     * Create a new command item from a keymap, commands, and options.
     */
    function createItem(commands, keymap, options) {
        return new CommandItem(commands, keymap, options);
    }
    Private.createItem = createItem;
    /**
     * Search the a sequence of command items for fuzzy matches.
     *
     * @param category - The category to match against the command items.
     *   If this is an empty string, all item categories will be matched.
     *
     * @param text - The text to match against the command items.
     *   If this is an empty string, all items will be matched.
     *
     * @returns The result of the search.
     */
    function search(items, category, text) {
        // Collect a mapping of the matching categories. The mapping will
        // only contain categories which match the provided query text.
        // If the category is an empty string, all categories will be
        // matched with a score of `0` and a `null` indices array.
        var catmap = matchCategory(items, category);
        // Filter the items for matching labels. Only items which have a
        // category in the given map are considered. The category score
        // is added to the label score to create the final item score.
        // If the text is an empty string, all items will be matched
        // with a label score of `0` and `null` indices array.
        var scores = matchLabel(items, text, catmap);
        // Sort the items based on their total item score. Ties are
        // broken by locale order of the category followed by label.
        scores.sort(scoreCmp);
        // Group the item scores by category. The categories are added
        // to the map in the order they appear in the scores array.
        var groups = groupScores(scores);
        // Return the result for the search. The headers are created in
        // the order of key iteration of the map. On all major browsers,
        // this is insertion order. This means that headers are created
        // in the order of first appearance in the sorted scores array.
        return createSearchResult(groups, catmap);
    }
    Private.search = search;
    /**
     * A concrete implementation of `CommandPalette.IItem`.
     */
    var CommandItem = (function () {
        /**
         * Construct a new command item.
         */
        function CommandItem(commands, keymap, options) {
            this._commands = commands;
            this._keymap = keymap;
            this._command = options.command;
            this._args = options.args || null;
            this._category = normalizeCategory(options.category || 'general');
        }
        Object.defineProperty(CommandItem.prototype, "command", {
            /**
             * The command to execute when the item is triggered.
             */
            get: function () {
                return this._command;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "args", {
            /**
             * The arguments for the command.
             */
            get: function () {
                return this._args;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "category", {
            /**
             * The category for the command item.
             */
            get: function () {
                return this._category;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "label", {
            /**
             * The display label for the command item.
             */
            get: function () {
                return this._commands.label(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "caption", {
            /**
             * The display caption for the command item.
             */
            get: function () {
                return this._commands.caption(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "className", {
            /**
             * The extra class name for the command item.
             */
            get: function () {
                return this._commands.className(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "isEnabled", {
            /**
             * Whether the command item is enabled.
             */
            get: function () {
                return this._commands.isEnabled(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "isToggled", {
            /**
             * Whether the command item is toggled.
             */
            get: function () {
                return this._commands.isToggled(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "isVisible", {
            /**
             * Whether the command item is visible.
             */
            get: function () {
                return this._commands.isVisible(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CommandItem.prototype, "keyBinding", {
            /**
             * The key binding for the command item.
             */
            get: function () {
                return this._keymap.findBinding(this._command, this._args);
            },
            enumerable: true,
            configurable: true
        });
        return CommandItem;
    }());
    /**
     * Normalize a category for a command item.
     */
    function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, ' ').toLowerCase();
    }
    /**
     * Normalize the query text for a command item.
     *
     * @param text - The category or text portion of a query.
     *
     * @returns The normalized query text.
     *
     * #### Notes
     * The text is normalized by converting to lower case and removing
     * all whitespace.
     */
    function normalizeQueryText(text) {
        return text.replace(/\s+/g, '').toLowerCase();
    }
    /**
     * Collect a mapping of the categories which match the given query.
     *
     * @param items - The command items to search.
     *
     * @param query - The category portion of the query.
     *
     * @returns A mapping of matched category to match score.
     *
     * #### Notes
     * The query string will be normalized by lower casing and removing
     * all whitespace. If the normalized query is an empty string, all
     * categories will be matched with a `0` score and `null` indices.
     *
     * Non-visible items will be ignored.
     */
    function matchCategory(items, query) {
        // Normalize the query text to lower case with no whitespace.
        query = normalizeQueryText(query);
        // Create the maps needed to track the match state.
        var seen = Object.create(null);
        var matched = Object.create(null);
        // Iterate over the items and match the categories.
        for (var i = 0, n = items.length; i < n; ++i) {
            // Ignore items which are not visible.
            var item = items.at(i);
            if (!item.isVisible) {
                continue;
            }
            // If a category has already been seen, no more work is needed.
            var category = item.category;
            if (category in seen) {
                continue;
            }
            // Mark the category as seen so it is only processed once.
            seen[category] = true;
            // If the query is empty, all categories match by default.
            if (!query) {
                matched[category] = { score: 0, indices: null };
                continue;
            }
            // Run the matcher for the query and skip if no match.
            var match = searching_1.StringSearch.sumOfSquares(category, query);
            if (!match) {
                continue;
            }
            // Store the match score in the results.
            matched[category] = match;
        }
        // Return the final mapping of matched categories.
        return matched;
    }
    /**
     * Filter command items for those with matching label and category.
     *
     * @param items - The command items to search.
     *
     * @param query - The text portion of the query.
     *
     * @param categories - A mapping of the valid item categories.
     *
     * @returns An array of item scores for the matching items.
     *
     * #### Notes
     * The query string will be normalized by lower casing and removing
     * all whitespace. If the normalized query is an empty string, all
     * items will be matched with a `0` label score and `null` indices.
     *
     * Items which have a category which is not present in the category
     * map will be ignored.
     *
     * Non-visible items will be ignored.
     *
     * The final item score is the sum of the item label score and the
     * relevant category score.
     */
    function matchLabel(items, query, categories) {
        // Normalize the query text to lower case with no whitespace.
        query = normalizeQueryText(query);
        // Create the array to hold the resulting scores.
        var scores = [];
        // Iterate over the items and match the text with the query.
        for (var i = 0, n = items.length; i < n; ++i) {
            // Ignore items which are not visible.
            var item = items.at(i);
            if (!item.isVisible) {
                continue;
            }
            // Look up the category score for the item category.
            var cs = categories[item.category];
            // If the category was not matched, the item is skipped.
            if (!cs) {
                continue;
            }
            // If the query is empty, all items are matched by default.
            if (!query) {
                scores.push({ score: cs.score, indices: null, item: item });
                continue;
            }
            // Run the matcher for the query and skip if no match.
            var match = searching_1.StringSearch.sumOfSquares(item.label.toLowerCase(), query);
            if (!match) {
                continue;
            }
            // Create the match score for the item.
            var score = cs.score + match.score;
            scores.push({ score: score, indices: match.indices, item: item });
        }
        // Return the final array of matched item scores.
        return scores;
    }
    /**
     * A sort comparison function for a command item match score.
     *
     * This orders the items first based on score (lower is better), then
     * by locale order of the item category followed by the item text.
     */
    function scoreCmp(a, b) {
        var d1 = a.score - b.score;
        if (d1 !== 0) {
            return d1;
        }
        var d2 = a.item.category.localeCompare(b.item.category);
        if (d2 !== 0) {
            return d2;
        }
        return a.item.label.localeCompare(b.item.label);
    }
    /**
     * Group item scores by item category.
     *
     * @param scores - The items to group by category.
     *
     * @returns A mapping of category name to group of items.
     *
     * #### Notes
     * The categories are added to the map in the order of first
     * appearance in the `scores` array.
     */
    function groupScores(scores) {
        var result = Object.create(null);
        for (var _i = 0, scores_1 = scores; _i < scores_1.length; _i++) {
            var score = scores_1[_i];
            var cat = score.item.category;
            (result[cat] || (result[cat] = [])).push(score);
        }
        return result;
    }
    /**
     * Create the search results for a collection of item scores.
     *
     * @param groups - The item scores, grouped by category.
     *
     * @param categories - A mapping of category scores.
     *
     * @returns New search results for the given scores.
     *
     * #### Notes
     * This function renders the groups in iteration order, which on
     * all major browsers is the order of insertion (by convention).
     */
    function createSearchResult(groups, categories) {
        var itemCount = 0;
        var headerCount = 0;
        var parts = [];
        for (var cat in groups) {
            headerCount++;
            parts.push(createHeaderPart(cat, categories[cat]));
            for (var _i = 0, _a = groups[cat]; _i < _a.length; _i++) {
                var score = _a[_i];
                itemCount++;
                parts.push(createItemPart(score));
            }
        }
        return { itemCount: itemCount, headerCount: headerCount, parts: parts };
    }
    /**
     * Create a header result part for the given data.
     *
     * @param category - The category name for the header.
     *
     * @param score - The score for the category match.
     *
     * @returns A header result part for the given data.
     */
    function createHeaderPart(category, score) {
        var markup = highlightText(category, score.indices);
        return { markup: markup, item: null };
    }
    /**
     * Create an item result part for the given data.
     *
     * @param score - The score for the item match.
     *
     * @returns An item result part for the given data.
     */
    function createItemPart(score) {
        var markup = highlightText(score.item.label, score.indices);
        return { markup: markup, item: score.item };
    }
    /**
     * Highlight the matching character of the given text.
     *
     * @param text - The text to highlight.
     *
     * @param indices - The character indices to highlight, or `null`.
     *
     * @returns The text interpolated with `<mark>` tags as needed.
     */
    function highlightText(text, indices) {
        return indices ? searching_1.StringSearch.highlight(text, indices) : text;
    }
})(Private || (Private = {}));
