"use strict";
var disposable_1 = require('../core/disposable');
var signaling_1 = require('../core/signaling');
/**
 * A registry which holds user-defined commands.
 */
var CommandRegistry = (function () {
    /**
     * Construct a new command registry.
     */
    function CommandRegistry() {
        this._commands = Object.create(null);
    }
    /**
     * List the ids of the registered commands.
     *
     * @returns A new array of the registered command ids.
     */
    CommandRegistry.prototype.listCommands = function () {
        return Object.keys(this._commands);
    };
    /**
     * Test whether a specific command is registered.
     *
     * @param id - The id of the command of interest.
     *
     * @returns `true` if the command is registered, `false` otherwise.
     */
    CommandRegistry.prototype.hasCommand = function (id) {
        return id in this._commands;
    };
    /**
     * Add a command to the registry.
     *
     * @param id - The unique id of the command.
     *
     * @param options - The options for the command.
     *
     * @returns A disposable which will unregister the command.
     *
     * @throws An error if the given `id` is already registered.
     */
    CommandRegistry.prototype.addCommand = function (id, options) {
        var _this = this;
        // Throw an error if the id is already registered.
        if (id in this._commands) {
            throw new Error("Command '" + id + "' already registered.");
        }
        // Create the command and add it to the registry.
        this._commands[id] = Private.createCommand(options);
        // Emit the `commandChanged` signal.
        this.commandChanged.emit({ id: id, type: 'added' });
        // Return a disposable which will remove the command.
        return new disposable_1.DisposableDelegate(function () {
            // Remove the command from the registry.
            delete _this._commands[id];
            // Emit the `commandChanged` signal.
            _this.commandChanged.emit({ id: id, type: 'removed' });
        });
    };
    /**
     * Notify listeners that the state of a command has changed.
     *
     * @param id - The id of the command which has changed.
     *
     * #### Notes
     * This method should be called by the command author whenever the
     * application state changes such that the results of the command
     * metadata functions may have changed.
     *
     * This will cause the `commandChanged` signal to be emitted.
     *
     * If the command is not registered, this is a no-op.
     */
    CommandRegistry.prototype.notifyCommandChanged = function (id) {
        if (id in this._commands) {
            this.commandChanged.emit({ id: id, type: 'changed' });
        }
    };
    /**
     * Get the display label for a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The display label for the command.
     *
     * #### Notes
     * Returns an empty string if the command is not registered.
     */
    CommandRegistry.prototype.label = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.label.call(void 0, args) : '';
    };
    /**
     * Get the mnemonic index for a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The mnemonic index for the command.
     *
     * #### Notes
     * Returns `-1` if the command is not registered.
     */
    CommandRegistry.prototype.mnemonic = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.mnemonic.call(void 0, args) : -1;
    };
    /**
     * Get the icon class for a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The icon class for the command.
     *
     * #### Notes
     * Returns an empty string if the command is not registered.
     */
    CommandRegistry.prototype.icon = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.icon.call(void 0, args) : '';
    };
    /**
     * Get the short form caption for a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The caption for the command.
     *
     * #### Notes
     * Returns an empty string if the command is not registered.
     */
    CommandRegistry.prototype.caption = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.caption.call(void 0, args) : '';
    };
    /**
     * Get the usage help text for a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The usage text for the command.
     *
     * #### Notes
     * Returns an empty string if the command is not registered.
     */
    CommandRegistry.prototype.usage = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.usage.call(void 0, args) : '';
    };
    /**
     * Get the extra class name for a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The class name for the command.
     *
     * #### Notes
     * Returns an empty string if the command is not registered.
     */
    CommandRegistry.prototype.className = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.className.call(void 0, args) : '';
    };
    /**
     * Test whether a specific command is enabled.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns `true` if the command is enabled, `false` otherwise.
     *
     * #### Notes
     * Returns `false` if the command is not registered.
     */
    CommandRegistry.prototype.isEnabled = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.isEnabled.call(void 0, args) : false;
    };
    /**
     * Test whether a specific command is toggled.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns `true` if the command is toggled, `false` otherwise.
     *
     * #### Notes
     * Returns `false` if the command is not registered.
     */
    CommandRegistry.prototype.isToggled = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.isToggled.call(void 0, args) : false;
    };
    /**
     * Test whether a specific command is visible.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns `true` if the command is visible, `false` otherwise.
     *
     * #### Notes
     * Returns `false` if the command is not registered.
     */
    CommandRegistry.prototype.isVisible = function (id, args) {
        var cmd = this._commands[id];
        return cmd ? cmd.isVisible.call(void 0, args) : false;
    };
    /**
     * Execute a specific command.
     *
     * @param id - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns A promise which resolves to the result of the command.
     *
     * #### Notes
     * The promise will reject if the command is not registered.
     */
    CommandRegistry.prototype.execute = function (id, args) {
        // Reject if the command is not registered.
        var cmd = this._commands[id];
        if (!cmd) {
            return Promise.reject(new Error("Command '" + id + "' not registered."));
        }
        // Execute the command and reject if an exception is thrown.
        var result;
        try {
            result = cmd.execute.call(void 0, args);
        }
        catch (err) {
            result = Promise.reject(err);
        }
        // Create the return promise which resolves the result.
        var promise = Promise.resolve(result);
        // Emit the command executed signal.
        this.commandExecuted.emit({ id: id, args: args });
        // Return the result promise to the caller.
        return promise;
    };
    return CommandRegistry;
}());
exports.CommandRegistry = CommandRegistry;
// Define the signals for the `CommandRegistry` class.
signaling_1.defineSignal(CommandRegistry.prototype, 'commandChanged');
signaling_1.defineSignal(CommandRegistry.prototype, 'commandExecuted');
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create a normalized command object from options.
     */
    function createCommand(options) {
        return {
            execute: options.execute,
            label: asStringFunc(options.label),
            mnemonic: asNumberFunc(options.mnemonic),
            icon: asStringFunc(options.icon),
            caption: asStringFunc(options.caption),
            usage: asStringFunc(options.usage),
            className: asStringFunc(options.className),
            isEnabled: options.isEnabled || trueFunc,
            isToggled: options.isToggled || falseFunc,
            isVisible: options.isVisible || trueFunc
        };
    }
    Private.createCommand = createCommand;
    /**
     * A singleton empty string function.
     */
    var emptyStringFunc = function (args) { return ''; };
    /**
     * A singleton `-1` number function
     */
    var negativeOneFunc = function (args) { return -1; };
    /**
     * A singleton true boolean function.
     */
    var trueFunc = function (args) { return true; };
    /**
     * A singleton false boolean function.
     */
    var falseFunc = function (args) { return false; };
    /**
     * Coerce a value to a string function.
     */
    function asStringFunc(value) {
        if (value === void 0) {
            return emptyStringFunc;
        }
        if (typeof value === 'function') {
            return value;
        }
        return function (args) { return value; };
    }
    /**
     * Coerce a value to a number function.
     */
    function asNumberFunc(value) {
        if (value === void 0) {
            return negativeOneFunc;
        }
        if (typeof value === 'function') {
            return value;
        }
        return function (args) { return value; };
    }
})(Private || (Private = {}));
