"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require('../algorithm/iteration');
var mutation_1 = require('../algorithm/mutation');
var searching_1 = require('../algorithm/searching');
var vector_1 = require('../collections/vector');
var messaging_1 = require('../core/messaging');
var signaling_1 = require('../core/signaling');
var cursor_1 = require('../dom/cursor');
var query_1 = require('../dom/query');
var title_1 = require('./title');
var vdom_1 = require('./vdom');
var widget_1 = require('./widget');
/**
 * The class name added to TabBar instances.
 */
var TAB_BAR_CLASS = 'p-TabBar';
/**
 * The class name added to a tab bar content node.
 */
var CONTENT_CLASS = 'p-TabBar-content';
/**
 * The class name added to a tab bar tab.
 */
var TAB_CLASS = 'p-TabBar-tab';
/**
 * The class name added to a tab label node.
 */
var LABEL_CLASS = 'p-TabBar-tabLabel';
/**
 * The class name added to a tab icon node.
 */
var ICON_CLASS = 'p-TabBar-tabIcon';
/**
 * The class name added to a tab close icon node.
 */
var CLOSE_ICON_CLASS = 'p-TabBar-tabCloseIcon';
/**
 * The class name added to a tab bar and tab when dragging.
 */
var DRAGGING_CLASS = 'p-mod-dragging';
/**
 * The class name added to the current tab.
 */
var CURRENT_CLASS = 'p-mod-current';
/**
 * The class name added to a closable tab.
 */
var CLOSABLE_CLASS = 'p-mod-closable';
/**
 * The start drag distance threshold.
 */
var DRAG_THRESHOLD = 5;
/**
 * The detach distance threshold.
 */
var DETACH_THRESHOLD = 20;
/**
 * The DOM structure for a TabBar.
 */
var TAB_BAR_NODE = (vdom_1.h.div(vdom_1.h.ul({ className: CONTENT_CLASS })));
/**
 * A widget which displays titles as a single row or column of tabs.
 *
 * #### Notes
 * If CSS transforms are used to rotate nodes for vertically oriented
 * text, then tab dragging will not work correctly. The `tabsMovable`
 * property should be set to `false` when rotating nodes from CSS.
 */
var TabBar = (function (_super) {
    __extends(TabBar, _super);
    /**
     * Construct a new tab bar.
     *
     * @param options - The options for initializing the tab bar.
     */
    function TabBar(options) {
        if (options === void 0) { options = {}; }
        _super.call(this, { node: vdom_1.realize(TAB_BAR_NODE) });
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles = new vector_1.Vector();
        this._dragData = null;
        this.addClass(TAB_BAR_CLASS);
        this.setFlag(widget_1.WidgetFlag.DisallowLayout);
        this._tabsMovable = options.tabsMovable || false;
        this._allowDeselect = options.allowDeselect || false;
        this._orientation = options.orientation || 'horizontal';
        this._renderer = options.renderer || TabBar.defaultRenderer;
        this._insertBehavior = options.insertBehavior || 'select-tab-if-needed';
        this._removeBehavior = options.removeBehavior || 'select-tab-after';
        this.addClass("p-mod-" + this._orientation);
    }
    /**
     * Dispose of the resources held by the widget.
     */
    TabBar.prototype.dispose = function () {
        this._releaseMouse();
        this._titles.clear();
        this._renderer = null;
        this._previousTitle = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabBar.prototype, "contentNode", {
        /**
         * Get the tab bar content node.
         *
         * #### Notes
         * This is the node which holds the tab nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "titles", {
        /**
         * A read-only sequence of the titles in the tab bar.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._titles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentTitle", {
        /**
         * Get the currently selected title.
         *
         * #### Notes
         * This will be `null` if no tab is selected.
         */
        get: function () {
            var i = this._currentIndex;
            return i !== -1 ? this._titles.at(i) : null;
        },
        /**
         * Set the currently selected title.
         *
         * #### Notes
         * If the title does not exist, the title will be set to `null`.
         */
        set: function (value) {
            this.currentIndex = searching_1.indexOf(this._titles, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentIndex", {
        /**
         * Get the index of the currently selected tab.
         *
         * #### Notes
         * This will be `-1` if no tab is selected.
         */
        get: function () {
            return this._currentIndex;
        },
        /**
         * Set the index of the currently selected tab.
         *
         * #### Notes
         * If the value is out of range, the index will be set to `-1`.
         */
        set: function (value) {
            // Coerce the value to an index.
            var i = Math.floor(value);
            if (i < 0 || i >= this._titles.length) {
                i = -1;
            }
            // Bail early if the index will not change.
            if (this._currentIndex === i) {
                return;
            }
            // Look up the previous index and title.
            var pi = this._currentIndex;
            var pt = pi === -1 ? null : this._titles.at(pi);
            // Look up the current index and title.
            var ci = i;
            var ct = ci === -1 ? null : this._titles.at(ci);
            // Update the current index and previous title.
            this._currentIndex = ci;
            this._previousTitle = pt;
            // Emit the current changed signal.
            this.currentChanged.emit({
                previousIndex: pi, previousTitle: pt,
                currentIndex: ci, currentTitle: ct
            });
            // Schedule an update of the tabs.
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "orientation", {
        /**
         * Get the orientation of the tab bar.
         *
         * #### Notes
         * This controls whether the tabs are arranged in a row or column.
         */
        get: function () {
            return this._orientation;
        },
        /**
         * Set the orientation of the tab bar.
         *
         * #### Notes
         * This controls whether the tabs are arranged in a row or column.
         */
        set: function (value) {
            // Do nothing if the orientation does not change.
            if (this._orientation === value) {
                return;
            }
            // Release the mouse before making any changes.
            this._releaseMouse();
            // Swap the orientation values.
            var old = this._orientation;
            this._orientation = value;
            // Toggle the orientation classes.
            this.removeClass("p-mod-" + old);
            this.addClass("p-mod-" + value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         *
         * #### Notes
         * Tabs can always be moved programmatically.
         */
        get: function () {
            return this._tabsMovable;
        },
        /**
         * Set whether the tabs are movable by the user.
         *
         * #### Notes
         * Tabs can always be moved programmatically.
         */
        set: function (value) {
            this._tabsMovable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "allowDeselect", {
        /**
         * Get whether a tab can be deselected by the user.
         *
         * #### Notes
         * Tabs can be always be deselected programmatically.
         */
        get: function () {
            return this._allowDeselect;
        },
        /**
         * Set whether a tab can be deselected by the user.
         *
         * #### Notes
         * Tabs can be always be deselected programmatically.
         */
        set: function (value) {
            this._allowDeselect = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "insertBehavior", {
        /**
         * Get the selection behavior when inserting a tab.
         */
        get: function () {
            return this._insertBehavior;
        },
        /**
         * Set the selection behavior when inserting a tab.
         */
        set: function (value) {
            this._insertBehavior = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "removeBehavior", {
        /**
         * Get the selection behavior when removing a tab.
         */
        get: function () {
            return this._removeBehavior;
        },
        /**
         * Set the selection behavior when removing a tab.
         */
        set: function (value) {
            this._removeBehavior = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "renderer", {
        /**
         * The renderer used by the tab bar.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a tab to the end of the tab bar.
     *
     * @param value - The title which holds the data for the tab,
     *   or an options object to convert to a title.
     *
     * @returns The title object added to the tab bar.
     *
     * #### Notes
     * If the title is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.addTab = function (value) {
        return this.insertTab(this._titles.length, value);
    };
    /**
     * Insert a tab into the tab bar at the specified index.
     *
     * @param index - The index at which to insert the tab.
     *
     * @param value - The title which holds the data for the tab,
     *   or an options object to convert to a title.
     *
     * @returns The title object added to the tab bar.
     *
     * #### Notes
     * The index will be clamped to the bounds of the tabs.
     *
     * If the title is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.insertTab = function (index, value) {
        // Release the mouse before making any changes.
        this._releaseMouse();
        // Coerce the value to a title.
        var title = Private.asTitle(value);
        // Look up the index of the title.
        var i = searching_1.indexOf(this._titles, title);
        // Clamp the insert index to the vector bounds.
        var j = Math.max(0, Math.min(Math.floor(index), this._titles.length));
        // If the title is not in the vector, insert it.
        if (i === -1) {
            // Insert the title into the vector.
            this._titles.insert(j, title);
            // Connect to the title changed signal.
            title.changed.connect(this._onTitleChanged, this);
            // Adjust the current index for the insert.
            this._adjustCurrentForInsert(j, title);
            // Schedule an update of the tabs.
            this.update();
            // Return the title added to the tab bar.
            return title;
        }
        // Otherwise, the title exists in the vector and should be moved.
        // Adjust the index if the location is at the end of the vector.
        if (j === this._titles.length)
            j--;
        // Bail if there is no effective move.
        if (i === j)
            return title;
        // Move the title to the new location.
        mutation_1.move(this._titles, i, j);
        // Adjust the current index for the move.
        this._adjustCurrentForMove(i, j);
        // Schedule an update of the tabs.
        this.update();
        // Return the title added to the tab bar.
        return title;
    };
    /**
     * Remove a tab from the tab bar.
     *
     * @param title - The title for the tab to remove.
     *
     * @returns The index occupied by the tab, or `-1` if the tab
     *   was not contained in the tab bar.
     */
    TabBar.prototype.removeTab = function (title) {
        var index = searching_1.indexOf(this._titles, title);
        if (index !== -1)
            this.removeTabAt(index);
        return index;
    };
    /**
     * Remove the tab at a given index from the tab bar.
     *
     * @param index - The index of the tab to remove.
     *
     * @returns The title occupying the index, or `null` if the index
     *   is out of range.
     */
    TabBar.prototype.removeTabAt = function (index) {
        // Bail if the index is out of range.
        var i = Math.floor(index);
        if (i < 0 || i >= this._titles.length) {
            return null;
        }
        // Release the mouse before making any changes.
        this._releaseMouse();
        // Remove the title from the vector.
        var title = this._titles.removeAt(i);
        // Disconnect from the title changed signal.
        title.changed.disconnect(this._onTitleChanged, this);
        // Clear the previous title if it's being removed.
        if (title === this._previousTitle) {
            this._previousTitle = null;
        }
        // Adjust the current index for the remove.
        this._adjustCurrentForRemove(i, title);
        // Schedule an update of the tabs.
        this.update();
        // Return the removed title.
        return title;
    };
    /**
     * Remove all tabs from the tab bar.
     */
    TabBar.prototype.clearTabs = function () {
        var _this = this;
        // Bail if there is nothing to remove.
        if (this._titles.length === 0) {
            return;
        }
        // Release the mouse before making any changes.
        this._releaseMouse();
        // Disconnect from the title changed signals.
        iteration_1.each(this._titles, function (title) {
            title.changed.disconnect(_this._onTitleChanged, _this);
        });
        // Get the current index and title.
        var pi = this.currentIndex;
        var pt = this.currentTitle;
        // Reset the current index and previous title.
        this._currentIndex = -1;
        this._previousTitle = null;
        // Clear the title vector.
        this._titles.clear();
        // Schedule an update of the tabs.
        this.update();
        // If no tab was selected, there's nothing else to do.
        if (pi === -1) {
            return;
        }
        // Emit the current changed signal.
        this.currentChanged.emit({
            previousIndex: pi, previousTitle: pt,
            currentIndex: -1, currentTitle: null
        });
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     *
     * #### Notes
     * This will cause the tab bar to stop handling mouse events and to
     * restore the tabs to their non-dragged positions.
     */
    TabBar.prototype.releaseMouse = function () {
        this._releaseMouse();
    };
    /**
     * Handle the DOM events for the tab bar.
     *
     * @param event - The DOM event sent to the tab bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the tab bar's DOM node.
     *
     * This should not be called directly by user code.
     */
    TabBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    TabBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    TabBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
        this._releaseMouse();
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    TabBar.prototype.onUpdateRequest = function (msg) {
        var content = [];
        var titles = this._titles;
        var renderer = this._renderer;
        var currentTitle = this.currentTitle;
        for (var i = 0, n = titles.length; i < n; ++i) {
            var title = titles.at(i);
            var current = title === currentTitle;
            var zIndex = current ? n : n - i - 1;
            content.push(renderer.renderTab({ title: title, current: current, zIndex: zIndex }));
        }
        vdom_1.render(content, this.contentNode);
    };
    /**
     * Handle the `'keydown'` event for the tab bar.
     */
    TabBar.prototype._evtKeyDown = function (event) {
        // Stop all input events during drag.
        event.preventDefault();
        event.stopPropagation();
        // Release the mouse if `Escape` is pressed.
        if (event.keyCode === 27)
            this._releaseMouse();
    };
    /**
     * Handle the `'click'` event for the tab bar.
     */
    TabBar.prototype._evtClick = function (event) {
        // Do nothing if it's not a left click.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Lookup the tab nodes.
        var tabs = this.contentNode.children;
        // Do nothing if the click is not on a tab.
        var x = event.clientX;
        var y = event.clientY;
        var i = searching_1.findIndex(tabs, function (tab) { return query_1.hitTest(tab, x, y); });
        if (i < 0) {
            return;
        }
        // Clicking on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the click if the title is not closable.
        var title = this._titles.at(i);
        if (!title.closable) {
            return;
        }
        // Ignore the click if it was not on a close icon.
        var icon = tabs[i].querySelector(this._renderer.closeIconSelector);
        if (!icon || !icon.contains(event.target)) {
            return;
        }
        // Emit the tab close requested signal.
        this.tabCloseRequested.emit({ index: i, title: title });
    };
    /**
     * Handle the `'mousedown'` event for the tab bar.
     */
    TabBar.prototype._evtMouseDown = function (event) {
        // Do nothing if it's not a left mouse press.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Lookup the tab nodes.
        var tabs = this.contentNode.children;
        // Do nothing if the press is not on a tab.
        var x = event.clientX;
        var y = event.clientY;
        var i = searching_1.findIndex(tabs, function (tab) { return query_1.hitTest(tab, x, y); });
        if (i < 0) {
            return;
        }
        // Pressing on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the press if it was on a close icon.
        var icon = tabs[i].querySelector(this._renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
            return;
        }
        // Setup the drag data if the tabs are movable.
        if (this._tabsMovable) {
            this._dragData = new Private.DragData();
            this._dragData.index = i;
            this._dragData.tab = tabs[i];
            this._dragData.pressX = event.clientX;
            this._dragData.pressY = event.clientY;
            document.addEventListener('mousemove', this, true);
            document.addEventListener('mouseup', this, true);
            document.addEventListener('keydown', this, true);
            document.addEventListener('contextmenu', this, true);
        }
        // Update the current index as appropriate.
        if (this._allowDeselect && this._currentIndex === i) {
            this.currentIndex = -1;
        }
        else {
            this.currentIndex = i;
        }
        // Do nothing else if there is no current tab.
        if (this._currentIndex === -1) {
            return;
        }
        // Emit the tab activate request signal.
        this.tabActivateRequested.emit({
            index: this.currentIndex,
            title: this.currentTitle
        });
    };
    /**
     * Handle the `'mousemove'` event for the tab bar.
     */
    TabBar.prototype._evtMouseMove = function (event) {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag.
        event.preventDefault();
        event.stopPropagation();
        // Lookup the tab nodes.
        var tabs = this.contentNode.children;
        // Check the threshold if the drag is not active.
        var data = this._dragData;
        if (!data.dragActive) {
            // Bail if the drag threshold is not exceeded.
            var dx = Math.abs(event.clientX - data.pressX);
            var dy = Math.abs(event.clientY - data.pressY);
            if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
                return;
            }
            // Fill in the rest of the drag data measurements.
            var tabRect = data.tab.getBoundingClientRect();
            if (this._orientation === 'horizontal') {
                data.tabPos = data.tab.offsetLeft;
                data.tabSize = tabRect.width;
                data.tabPressPos = data.pressX - tabRect.left;
            }
            else {
                data.tabPos = data.tab.offsetTop;
                data.tabSize = tabRect.height;
                data.tabPressPos = data.pressY - tabRect.top;
            }
            data.tabLayout = Private.snapTabLayout(tabs, this._orientation);
            data.contentRect = this.contentNode.getBoundingClientRect();
            data.override = cursor_1.overrideCursor('default');
            // Add the dragging style classes.
            data.tab.classList.add(DRAGGING_CLASS);
            this.addClass(DRAGGING_CLASS);
            // Mark the drag as active.
            data.dragActive = true;
        }
        // Emit the detach requested signal if the threshold is exceeded.
        if (!data.detachRequested && Private.detachExceeded(data, event)) {
            // Only emit the signal once per drag cycle.
            data.detachRequested = true;
            // Setup the arguments for the signal.
            var index = data.index;
            var clientX = event.clientX;
            var clientY = event.clientY;
            var tab = tabs[index];
            var title = this._titles.at(index);
            // Emit the tab detach requested signal.
            this.tabDetachRequested.emit({ index: index, title: title, tab: tab, clientX: clientX, clientY: clientY });
            // Bail if the signal handler aborted the drag.
            if (data.dragAborted) {
                return;
            }
        }
        // Update the positions of the tabs.
        Private.layoutTabs(tabs, data, event, this._orientation);
    };
    /**
     * Handle the `'mouseup'` event for the tab bar.
     */
    TabBar.prototype._evtMouseUp = function (event) {
        var _this = this;
        // Do nothing if it's not a left mouse release.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag operation.
        event.preventDefault();
        event.stopPropagation();
        // Remove the extra mouse event listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Bail early if the drag is not active.
        var data = this._dragData;
        if (!data.dragActive) {
            this._dragData = null;
            return;
        }
        // Position the tab at its final resting position.
        Private.finalizeTabPosition(data, this._orientation);
        // Remove the dragging class from the tab so it can be transitioned.
        data.tab.classList.remove(DRAGGING_CLASS);
        // Parse the transition duration for releasing the tab.
        var duration = Private.parseTransitionDuration(data.tab);
        // Complete the release on a timer to allow the tab to transition.
        setTimeout(function () {
            // Do nothing if the drag has been aborted.
            if (data.dragAborted) {
                return;
            }
            // Clear the drag data reference.
            _this._dragData = null;
            // Reset the positions of the tabs.
            Private.resetTabPositions(_this.contentNode.children, _this._orientation);
            // Clear the cursor grab.
            data.override.dispose();
            // Remove the remaining dragging style.
            _this.removeClass(DRAGGING_CLASS);
            // If the tab was not moved, there is nothing else to do.
            var i = data.index;
            var j = data.targetIndex;
            if (j === -1 || i === j) {
                return;
            }
            // Move the title to the new locations.
            mutation_1.move(_this._titles, i, j);
            // Adjust the current index for the move.
            _this._adjustCurrentForMove(i, j);
            // Emit the tab moved signal.
            _this.tabMoved.emit({
                fromIndex: i, toIndex: j, title: _this._titles.at(j)
            });
            // Update the tabs immediately to prevent flicker.
            messaging_1.sendMessage(_this, widget_1.WidgetMessage.UpdateRequest);
        }, duration);
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     */
    TabBar.prototype._releaseMouse = function () {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Remove the extra mouse listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Clear the drag data reference.
        var data = this._dragData;
        this._dragData = null;
        // Indicate the drag has been aborted. This allows the mouse
        // event handlers to return early when the drag is canceled.
        data.dragAborted = true;
        // If the drag is not active, there's nothing more to do.
        if (!data.dragActive) {
            return;
        }
        // Reset the tabs to their non-dragged positions.
        Private.resetTabPositions(this.contentNode.children, this._orientation);
        // Clear the cursor override.
        data.override.dispose();
        // Clear the dragging style classes.
        data.tab.classList.remove(DRAGGING_CLASS);
        this.removeClass(DRAGGING_CLASS);
    };
    /**
     * Adjust the current index for a tab insert operation.
     *
     * This method accounts for the tab bar's insertion behavior when
     * adjusting the current index and emitting the changed signal.
     */
    TabBar.prototype._adjustCurrentForInsert = function (i, title) {
        // Lookup commonly used variables.
        var ct = this.currentTitle;
        var ci = this._currentIndex;
        var bh = this._insertBehavior;
        // Handle the behavior where the new tab is always selected,
        // or the behavior where the new tab is selected if needed.
        if (bh === 'select-tab' || (bh === 'select-tab-if-needed' && ci === -1)) {
            this._currentIndex = i;
            this._previousTitle = ct;
            this.currentChanged.emit({
                previousIndex: ci, previousTitle: ct,
                currentIndex: i, currentTitle: title
            });
            return;
        }
        // Otherwise, silently adjust the current index if needed.
        if (ci >= i)
            this._currentIndex++;
    };
    /**
     * Adjust the current index for a tab move operation.
     *
     * This method will not cause the actual current tab to change.
     * It silently adjusts the index to account for the given move.
     */
    TabBar.prototype._adjustCurrentForMove = function (i, j) {
        if (this._currentIndex === i) {
            this._currentIndex = j;
        }
        else if (this._currentIndex < i && this._currentIndex >= j) {
            this._currentIndex++;
        }
        else if (this._currentIndex > i && this._currentIndex <= j) {
            this._currentIndex--;
        }
    };
    /**
     * Adjust the current index for a tab remove operation.
     *
     * This method accounts for the tab bar's remove behavior when
     * adjusting the current index and emitting the changed signal.
     */
    TabBar.prototype._adjustCurrentForRemove = function (i, title) {
        // Lookup commonly used variables.
        var ci = this._currentIndex;
        var bh = this._removeBehavior;
        // Silently adjust the index if the current tab is not removed.
        if (ci !== i) {
            if (ci > i)
                this._currentIndex--;
            return;
        }
        // No tab gets selected if the tab bar is empty.
        if (this._titles.length === 0) {
            this._currentIndex = -1;
            this.currentChanged.emit({
                previousIndex: i, previousTitle: title,
                currentIndex: -1, currentTitle: null
            });
            return;
        }
        // Handle behavior where the next sibling tab is selected.
        if (bh === 'select-tab-after') {
            this._currentIndex = Math.min(i, this._titles.length - 1);
            this.currentChanged.emit({
                previousIndex: i, previousTitle: title,
                currentIndex: this._currentIndex, currentTitle: this.currentTitle
            });
            return;
        }
        // Handle behavior where the previous sibling tab is selected.
        if (bh === 'select-tab-before') {
            this._currentIndex = Math.max(0, i - 1);
            this.currentChanged.emit({
                previousIndex: i, previousTitle: title,
                currentIndex: this._currentIndex, currentTitle: this.currentTitle
            });
            return;
        }
        // Handle behavior where the previous history tab is selected.
        if (bh === 'select-previous-tab') {
            if (this._previousTitle) {
                this._currentIndex = searching_1.indexOf(this._titles, this._previousTitle);
                this._previousTitle = null;
            }
            else {
                this._currentIndex = Math.min(i, this._titles.length - 1);
            }
            this.currentChanged.emit({
                previousIndex: i, previousTitle: title,
                currentIndex: this._currentIndex, currentTitle: this.currentTitle
            });
            return;
        }
        // Otherwise, no tab gets selected.
        this._currentIndex = -1;
        this.currentChanged.emit({
            previousIndex: i, previousTitle: title,
            currentIndex: -1, currentTitle: null
        });
    };
    /**
     * Handle the `changed` signal of a title object.
     */
    TabBar.prototype._onTitleChanged = function (sender) {
        this.update();
    };
    return TabBar;
}(widget_1.Widget));
exports.TabBar = TabBar;
// Define the signals for the `TabBar` class.
signaling_1.defineSignal(TabBar.prototype, 'currentChanged');
signaling_1.defineSignal(TabBar.prototype, 'tabMoved');
signaling_1.defineSignal(TabBar.prototype, 'tabActivateRequested');
signaling_1.defineSignal(TabBar.prototype, 'tabCloseRequested');
signaling_1.defineSignal(TabBar.prototype, 'tabDetachRequested');
/**
 * The namespace for the `TabBar` class statics.
 */
var TabBar;
(function (TabBar) {
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        /**
         * Construct a new renderer.
         *
         * @param options - The options for initializing the renderer.
         */
        function Renderer(options) {
            if (options === void 0) { options = {}; }
            this._tabID = 0;
            this._tabKeys = new WeakMap();
            this._extraTabClass = options.extraTabClass || '';
        }
        Object.defineProperty(Renderer.prototype, "closeIconSelector", {
            /**
             * A selector which matches the close icon node in a tab.
             *
             * #### Notes
             * This is a read-only property.
             */
            get: function () {
                return "." + CLOSE_ICON_CLASS;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Render the node for the a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual DOM node representing the tab.
         */
        Renderer.prototype.renderTab = function (data) {
            var _a = data.title, label = _a.label, caption = _a.caption;
            var key = this.createTabKey(data);
            var style = this.createTabStyle(data);
            var tabClass = this.createTabClass(data);
            var iconClass = this.createIconClass(data);
            return (vdom_1.h.li({ key: key, className: tabClass, title: caption, style: style }, vdom_1.h.div({ className: iconClass }), vdom_1.h.div({ className: LABEL_CLASS }, label), vdom_1.h.div({ className: CLOSE_ICON_CLASS })));
        };
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        Renderer.prototype.createTabKey = function (data) {
            var key = this._tabKeys.get(data.title);
            if (key === void 0) {
                key = "tab-key-" + this._tabID++;
                this._tabKeys.set(data.title, key);
            }
            return key;
        };
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        Renderer.prototype.createTabStyle = function (data) {
            return { zIndex: "" + data.zIndex };
        };
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        Renderer.prototype.createTabClass = function (data) {
            var title = data.title, current = data.current;
            var name = TAB_CLASS;
            if (title.className) {
                name += " " + title.className;
            }
            if (title.closable) {
                name += " " + CLOSABLE_CLASS;
            }
            if (current) {
                name += " " + CURRENT_CLASS;
            }
            if (this._extraTabClass) {
                name += " " + this._extraTabClass;
            }
            return name;
        };
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        Renderer.prototype.createIconClass = function (data) {
            var title = data.title;
            var name = ICON_CLASS;
            if (title.icon) {
                name += " " + title.icon;
            }
            return name;
        };
        return Renderer;
    }());
    TabBar.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    TabBar.defaultRenderer = new Renderer();
})(TabBar = exports.TabBar || (exports.TabBar = {}));
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * A struct which holds the drag data for a tab bar.
     */
    var DragData = (function () {
        function DragData() {
            /**
             * The tab node being dragged.
             */
            this.tab = null;
            /**
             * The index of the tab being dragged.
             */
            this.index = -1;
            /**
             * The offset left/top of the tab being dragged.
             */
            this.tabPos = -1;
            /**
             * The offset width/height of the tab being dragged.
             */
            this.tabSize = -1;
            /**
             * The original mouse X/Y position in tab coordinates.
             */
            this.tabPressPos = -1;
            /**
             * The tab target index upon mouse release.
             */
            this.targetIndex = -1;
            /**
             * The array of tab layout objects snapped at drag start.
             */
            this.tabLayout = null;
            /**
             * The mouse press client X position.
             */
            this.pressX = -1;
            /**
             * The mouse press client Y position.
             */
            this.pressY = -1;
            /**
             * The bounding client rect of the tab bar content node.
             */
            this.contentRect = null;
            /**
             * The disposable to clean up the cursor override.
             */
            this.override = null;
            /**
             * Whether the drag is currently active.
             */
            this.dragActive = false;
            /**
             * Whether the drag has been aborted.
             */
            this.dragAborted = false;
            /**
             * Whether a detach request as been made.
             */
            this.detachRequested = false;
        }
        return DragData;
    }());
    Private.DragData = DragData;
    /**
     * Coerce a title or options into a real title.
     */
    function asTitle(value) {
        return value instanceof title_1.Title ? value : new title_1.Title(value);
    }
    Private.asTitle = asTitle;
    /**
     * Parse the transition duration for a tab node.
     */
    function parseTransitionDuration(tab) {
        var style = window.getComputedStyle(tab);
        return 1000 * (parseFloat(style.transitionDuration) || 0);
    }
    Private.parseTransitionDuration = parseTransitionDuration;
    /**
     * Get a snapshot of the current tab layout values.
     */
    function snapTabLayout(tabs, orientation) {
        var layout = new Array(tabs.length);
        if (orientation === 'horizontal') {
            for (var i = 0, n = tabs.length; i < n; ++i) {
                var node = tabs[i];
                var pos = node.offsetLeft;
                var size = node.offsetWidth;
                var cstyle = window.getComputedStyle(node);
                var margin = parseInt(cstyle.marginLeft, 10) || 0;
                layout[i] = { margin: margin, pos: pos, size: size };
            }
        }
        else {
            for (var i = 0, n = tabs.length; i < n; ++i) {
                var node = tabs[i];
                var pos = node.offsetTop;
                var size = node.offsetHeight;
                var cstyle = window.getComputedStyle(node);
                var margin = parseInt(cstyle.marginTop, 10) || 0;
                layout[i] = { margin: margin, pos: pos, size: size };
            }
        }
        return layout;
    }
    Private.snapTabLayout = snapTabLayout;
    /**
     * Test if the event exceeds the drag detach threshold.
     */
    function detachExceeded(data, event) {
        var rect = data.contentRect;
        return ((event.clientX < rect.left - DETACH_THRESHOLD) ||
            (event.clientX >= rect.right + DETACH_THRESHOLD) ||
            (event.clientY < rect.top - DETACH_THRESHOLD) ||
            (event.clientY >= rect.bottom + DETACH_THRESHOLD));
    }
    Private.detachExceeded = detachExceeded;
    /**
     * Update the relative tab positions and computed target index.
     */
    function layoutTabs(tabs, data, event, orientation) {
        // Compute the orientation-sensitive values.
        var pressPos;
        var localPos;
        var clientPos;
        var clientSize;
        if (orientation === 'horizontal') {
            pressPos = data.pressX;
            localPos = event.clientX - data.contentRect.left;
            clientPos = event.clientX;
            clientSize = data.contentRect.width;
        }
        else {
            pressPos = data.pressY;
            localPos = event.clientY - data.contentRect.top;
            clientPos = event.clientY;
            clientSize = data.contentRect.height;
        }
        // Compute the target data.
        var targetIndex = data.index;
        var targetPos = localPos - data.tabPressPos;
        var targetEnd = targetPos + data.tabSize;
        // Update the relative tab positions.
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var pxPos = void 0;
            var layout = data.tabLayout[i];
            var threshold = layout.pos + (layout.size >> 1);
            if (i < data.index && targetPos < threshold) {
                pxPos = (data.tabSize + data.tabLayout[i + 1].margin) + "px";
                targetIndex = Math.min(targetIndex, i);
            }
            else if (i > data.index && targetEnd > threshold) {
                pxPos = (-data.tabSize - layout.margin) + "px";
                targetIndex = Math.max(targetIndex, i);
            }
            else if (i === data.index) {
                var ideal = clientPos - pressPos;
                var limit = clientSize - (data.tabPos + data.tabSize);
                pxPos = Math.max(-data.tabPos, Math.min(ideal, limit)) + "px";
            }
            else {
                pxPos = '';
            }
            if (orientation === 'horizontal') {
                tabs[i].style.left = pxPos;
            }
            else {
                tabs[i].style.top = pxPos;
            }
        }
        // Update the computed target index.
        data.targetIndex = targetIndex;
    }
    Private.layoutTabs = layoutTabs;
    /**
     * Position the drag tab at its final resting relative position.
     */
    function finalizeTabPosition(data, orientation) {
        // Compute the orientation-sensitive client size.
        var clientSize;
        if (orientation === 'horizontal') {
            clientSize = data.contentRect.width;
        }
        else {
            clientSize = data.contentRect.height;
        }
        // Compute the ideal final tab position.
        var ideal;
        if (data.targetIndex === data.index) {
            ideal = 0;
        }
        else if (data.targetIndex > data.index) {
            var tgt = data.tabLayout[data.targetIndex];
            ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        }
        else {
            var tgt = data.tabLayout[data.targetIndex];
            ideal = tgt.pos - data.tabPos;
        }
        // Compute the tab position limit.
        var limit = clientSize - (data.tabPos + data.tabSize);
        var final = Math.max(-data.tabPos, Math.min(ideal, limit));
        // Set the final orientation-sensitive position.
        if (orientation === 'horizontal') {
            data.tab.style.left = final + "px";
        }
        else {
            data.tab.style.top = final + "px";
        }
    }
    Private.finalizeTabPosition = finalizeTabPosition;
    /**
     * Reset the relative positions of the given tabs.
     */
    function resetTabPositions(tabs, orientation) {
        if (orientation === 'horizontal') {
            iteration_1.each(tabs, function (tab) { tab.style.left = ''; });
        }
        else {
            iteration_1.each(tabs, function (tab) { tab.style.top = ''; });
        }
    }
    Private.resetTabPositions = resetTabPositions;
})(Private || (Private = {}));
