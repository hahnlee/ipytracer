/**
 * A message which can be delivered to a message handler.
 *
 * #### Notes
 * This class may be subclassed to create complex message types.
 *
 * **See also:** [[postMessage]] and [[sendMessage]].
 */
export declare class Message {
    /**
     * Construct a new message.
     *
     * @param type - The type of the message.
     */
    constructor(type: string);
    /**
     * The type of the message.
     *
     * #### Notes
     * This value can be used to cast the message to a derived type.
     *
     * This is a read-only property.
     */
    readonly type: string;
    /**
     * Test whether the message is conflatable.
     *
     * #### Notes
     * Message conflation is an advanced topic. Most message types will
     * not make use of this feature.
     *
     * If a conflatable message is posted to the event queue when another
     * conflatable message of the same type and handler has already been
     * posted, the `conflate()` method of the existing message will be
     * invoked. If that method returns `true`, the new message will not
     * be enqueued. This allows messages to be compressed, so that only
     * a single instance of the message type is processed per cycle, no
     * matter how many times messages of that type are posted.
     *
     * Custom message types may reimplement this property. The default
     * implementation is always `false`.
     *
     * This is a read-only property.
     *
     * **See also:** [[conflateMessage]]
     */
    readonly isConflatable: boolean;
    /**
     * Conflate this message with another message of the same `type`.
     *
     * @param other - A conflatable message of the same `type`.
     *
     * @returns `true` if the message was successfully conflated, or
     *   `false` otherwise.
     *
     * #### Notes
     * Message conflation is an advanced topic. Most message types will
     * not make use of this feature.
     *
     * This method is called automatically by the message loop when the
     * given message is posted to the handler paired with this message.
     * This message will already be enqueued and conflatable, and the
     * given message will have the same `type` and also be conflatable.
     *
     * This method should merge the state of the other message into this
     * message as needed so that when this message is finally delivered
     * to the handler, it receives the most up-to-date information.
     *
     * If this method returns `true`, it signals that the other message
     * was successfully conflated and it will not be enqueued.
     *
     * If this method returns `false`, the other message will be enqueued
     * for normal delivery.
     *
     * Custom message types may reimplement this method. The default
     * implementation always returns `false`.
     *
     * **See also:** [[isConflatable]]
     */
    conflate(other: Message): boolean;
    private _type;
}
/**
 * A convenience message class which conflates automatically.
 *
 * #### Notes
 * Message conflation is an advanced topic. Most user code will not
 * make use of this class.
 *
 * This message class is useful for creating message instances which
 * should be conflated, but which have no state other than `type`.
 *
 * If conflation of stateful messages is required, a custom `Message`
 * subclass should be created.
 */
export declare class ConflatableMessage extends Message {
    /**
     * Test whether the message is conflatable.
     *
     * #### Notes
     * This property is always `true`.
     *
     * This is a read-only property.
     */
    readonly isConflatable: boolean;
    /**
     * Conflate this message with another message of the same `type`.
     *
     * #### Notes
     * This method always returns `true`.
     */
    conflate(other: ConflatableMessage): boolean;
}
/**
 * An object which handles messages.
 *
 * #### Notes
 * A message handler is a simple way of defining a type which can act
 * upon on a large variety of external input without requiring a large
 * abstract API surface. This is particularly useful in the context of
 * widget frameworks where the number of distinct message types can be
 * unbounded.
 *
 * **See also:** [[postMessage]] and [[sendMessage]].
 */
export interface IMessageHandler {
    /**
     * Process a message sent to the handler.
     *
     * @param msg - The message to be processed.
     */
    processMessage(msg: Message): void;
}
/**
 * A function which intercepts messages sent to a message handler.
 *
 * @param handler - The target handler of the message.
 *
 * @param msg - The message to be sent to the handler.
 *
 * @returns `true` if the message should continue to be processed
 *   as normal, or `false` if processing should cease immediately.
 *
 * #### Notes
 * A message hook is useful for intercepting or spying on messages
 * sent to message handlers which were either not created by the
 * consumer, or when subclassing the handler is not feasible.
 *
 * If the function returns `false`, no other message hooks will be
 * invoked and the message will not be delivered to the handler.
 *
 * If all installed message hooks return `true`, the message will
 * be delivered to the handler for processing.
 *
 * **See also:** [[installMessageHook]] and [[removeMessageHook]]
 */
export declare type MessageHook = (handler: IMessageHandler, msg: Message) => boolean;
/**
 * Send a message to a message handler to process immediately.
 *
 * @param handler - The handler which should process the message.
 *
 * @param msg - The message to deliver to the handler.
 *
 * #### Notes
 * The message will first be sent through any installed message hooks
 * for the handler. If the message passes all hooks, it will then be
 * delivered to the `processMessage` method of the handler.
 *
 * The message will not be conflated with pending posted messages.
 *
 * Exceptions in hooks and handlers will be caught and logged.
 */
export declare function sendMessage(handler: IMessageHandler, msg: Message): void;
/**
 * Post a message to the message handler to process in the future.
 *
 * @param handler - The handler which should process the message.
 *
 * @param msg - The message to post to the handler.
 *
 * #### Notes
 * The message will be conflated with the pending posted messages for
 * the handler, if possible. If the message is not conflated, it will
 * be queued for normal delivery on the next cycle of the event loop.
 *
 * Exceptions in hooks and handlers will be caught and logged.
 */
export declare function postMessage(handler: IMessageHandler, msg: Message): void;
/**
 * Install a message hook for a message handler.
 *
 * @param handler - The message handler of interest.
 *
 * @param hook - The message hook to install.
 *
 * #### Notes
 * A message hook is invoked before a message is delivered to the
 * handler. If the hook returns `false`, no other hooks will be
 * invoked and the message will not be delivered to the handler.
 *
 * The most recently installed message hook is executed first.
 *
 * If the hook is already installed, it will be moved to the front.
 *
 * **See also:** [[removeMessageHook]]
 */
export declare function installMessageHook(handler: IMessageHandler, hook: MessageHook): void;
/**
 * Remove an installed message hook for a message handler.
 *
 * @param handler - The message handler of interest.
 *
 * @param hook - The message hook to remove.
 *
 * #### Notes
 * If the hook is not installed, this is a no-op.
 *
 * It is safe to call this function while the hook is executing.
 */
export declare function removeMessageHook(handler: IMessageHandler, hook: MessageHook): void;
/**
 * Clear all message data associated with a message handler.
 *
 * @param handler - The message handler of interest.
 *
 * #### Notes
 * This will clear all pending messages and hooks for the handler.
 */
export declare function clearMessageData(handler: IMessageHandler): void;
