import * as Backbone from 'backbone';
import * as services from '@jupyterlab/services';
import { WidgetModel } from './widget';
import { shims } from './services-shim';
/**
 * The options for a model.
 *
 * #### Notes
 * Either a comm or a model_id must be provided.
 */
export interface ModelOptions {
    /**
     * Target name of the widget model to create.
     */
    model_name: string;
    /**
     * Module name of the widget model to create.
     */
    model_module: string;
    /**
     * Semver version requirement for the model module.
     */
    model_module_version: string;
    /**
     * Target name of the widget in the back end.
     */
    widget_class?: string;
    /**
     * Comm object associated with the widget.
     */
    comm?: any;
    /**
     * The model id to use. If not provided, the comm id of the comm is used.
     */
    model_id?: string;
}
export interface StateOptions {
    /**
     * Only return models with one or more displayed views.
     *
     * @default false
     */
    only_displayed?: boolean;
    /**
     * Include models that have comms with severed connections.
     *
     * @default false
     */
    not_live?: boolean;
    /**
     * Drop model attributes that are equal to their default value.
     *
     * @default false
     */
    drop_defaults?: boolean;
}
/**
 * Manager abstract base class
 */
export declare abstract class ManagerBase<T> {
    /**
     * The comm target name to register.
     */
    readonly comm_target_name: string;
    /**
     * The version comm target name to register.
     */
    readonly version_comm_target_name: string;
    /**
     * Display a view for a particular model.
     */
    display_model(msg: services.KernelMessage.IMessage, model: Backbone.Model, options: any): Promise<T>;
    /**
     * Display a view.
     *
     * #### Notes
     * This must be implemented by a subclass. The implementation must trigger the view's displayed
     * event after the view is on the page: `view.trigger('displayed')`
     */
    abstract display_view(msg: services.KernelMessage.IMessage, view: Backbone.View<Backbone.Model>, options: any): Promise<T>;
    /**
     * Modifies view options. Generally overloaded in custom widget manager
     * implementations.
     */
    setViewOptions(options: any): any;
    /**
     * Takes a requirejs success handler and returns a requirejs error handler.
     * The default implementation just throws the original error.
     */
    require_error(success_callback: any, version: string): (err: any) => any;
    /**
     * Creates a promise for a view of a given model
     *
     * Make sure the view creation is not out of order with
     * any state updates.
     */
    create_view(model: any, options: any): any;
    /**
     * callback handlers specific to a view
     */
    callbacks(view: any): {};
    /**
     * Get a promise for a model by model id.
     */
    get_model(model_id: string): Promise<Backbone.Model>;
    /**
     * Handle when a comm is opened.
     */
    handle_comm_open(comm: shims.services.Comm, msg: services.KernelMessage.ICommOpenMsg): Promise<Backbone.Model>;
    /**
     * Create a comm and new widget model.
     * @param  options - same options as new_model but, comm is not
     *                          required and additional options are available.
     * @param  serialized_state - serialized model attributes.
     */
    new_widget(options: ModelOptions, serialized_state: any): Promise<WidgetModel>;
    /**
     * Validate the version of the Javascript against the version requested by
     * the backend.
     * @return Whether or not the versions are okay
     */
    validateVersion(): Promise<boolean>;
    /**
     * Create and return a promise for a new widget model
     *
     * Minimally, one must provide the model_name and widget_class
     * parameters to create a model from Javascript.
     *
     * @param options - the options for creating the model.
     * @param serialized_state - attribute values for the model.
     *
     * @example
     * widget_manager.new_model({
     *      model_name: 'WidgetModel',
     *      widget_class: 'Jupyter.IntSlider'
     *  })
     *  .then((model) => { console.log('Create success!', model); },
     *  (err) => {console.error(err)});
     *
     */
    new_model(options: ModelOptions, serialized_state?: any): Promise<any>;
    /**

    * Close all widgets and empty the widget state.
    * @param commlessOnly should only commless widgets be removed
    * @return promise that resolves when the widget state is cleared.
    */
    clear_state(commlessOnly: boolean): Promise<void>;
    /**
     * Asynchronously get the state of the widget manager.
     *
     * This includes all of the widget models.
     *
     * @param options - The options for what state to return.
     * @returns Promise for a state dictionary
     */
    get_state(options: StateOptions): Promise<any>;
    /**
     * Set the widget manager state.
     *
     * Reconstructs all of the widget models in the state, merges that with the
     * current manager state, and then attempts to redisplay the widgets in the
     * state.
     */
    set_state(state: any, displayOptions: any): any;
    /**
     * Load a class and return a promise to the loaded object.
     */
    protected loadClass(className: any, moduleName: any, moduleVersion: any, error: any): Promise<any>;
    abstract _create_comm(comm_target_name: any, model_id: any, data?: any): Promise<any>;
    abstract _get_comm_info(): any;
    /**
     * Dictionary of model ids and model instance promises
     */
    private _models;
}
