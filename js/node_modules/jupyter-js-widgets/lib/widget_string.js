// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var widget_1 = require("./widget");
var _ = require("underscore");
var StringModel = (function (_super) {
    __extends(StringModel, _super);
    function StringModel() {
        return _super.apply(this, arguments) || this;
    }
    StringModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            value: '',
            disabled: false,
            placeholder: '\u200b',
            _model_name: 'StringModel'
        });
    };
    return StringModel;
}(widget_1.LabeledDOMWidgetModel));
exports.StringModel = StringModel;
var HTMLModel = (function (_super) {
    __extends(HTMLModel, _super);
    function HTMLModel() {
        return _super.apply(this, arguments) || this;
    }
    HTMLModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _view_name: 'HTMLView',
            _model_name: 'HTMLModel'
        });
    };
    return HTMLModel;
}(StringModel));
exports.HTMLModel = HTMLModel;
var HTMLView = (function (_super) {
    __extends(HTMLView, _super);
    function HTMLView() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Called when view is rendered.
     */
    HTMLView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-html');
        this.update(); // Set defaults.
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    HTMLView.prototype.update = function () {
        this.el.innerHTML = this.model.get('value');
        return _super.prototype.update.call(this);
    };
    return HTMLView;
}(widget_1.LabeledDOMWidgetView));
exports.HTMLView = HTMLView;
var LabelModel = (function (_super) {
    __extends(LabelModel, _super);
    function LabelModel() {
        return _super.apply(this, arguments) || this;
    }
    LabelModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _view_name: 'LabelView',
            _model_name: 'LabelModel'
        });
    };
    return LabelModel;
}(StringModel));
exports.LabelModel = LabelModel;
var LabelView = (function (_super) {
    __extends(LabelView, _super);
    function LabelView() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Called when view is rendered.
     */
    LabelView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-label');
        this.update(); // Set defaults.
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    LabelView.prototype.update = function () {
        this.typeset(this.el, this.model.get('value'));
        return _super.prototype.update.call(this);
    };
    return LabelView;
}(widget_1.LabeledDOMWidgetView));
exports.LabelView = LabelView;
var TextareaModel = (function (_super) {
    __extends(TextareaModel, _super);
    function TextareaModel() {
        return _super.apply(this, arguments) || this;
    }
    TextareaModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _view_name: 'TextareaView',
            _model_name: 'TextareaModel'
        });
    };
    return TextareaModel;
}(StringModel));
exports.TextareaModel = TextareaModel;
var TextareaView = (function (_super) {
    __extends(TextareaView, _super);
    function TextareaView() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Called when view is rendered.
     */
    TextareaView.prototype.render = function () {
        var _this = this;
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-textarea');
        this.textbox = document.createElement('textarea');
        this.textbox.setAttribute('rows', '5');
        this.el.appendChild(this.textbox);
        this.update(); // Set defaults.
        this.listenTo(this.model, 'msg:custom', function (content) {
            _this._handle_textarea_msg(content);
        });
        this.listenTo(this.model, 'change:placeholder', function (model, value, options) {
            this.update_placeholder(value);
        });
        this.update_placeholder();
    };
    /**
     * Handle when a custom msg is recieved from the back-end.
     */
    TextareaView.prototype._handle_textarea_msg = function (content) {
        if (content.method == 'scroll_to_bottom') {
            this.scroll_to_bottom();
        }
    };
    TextareaView.prototype.update_placeholder = function (value) {
        value = value || this.model.get('placeholder');
        this.textbox.setAttribute('placeholder', value.toString());
    };
    /**
     * Scroll the text-area view to the bottom.
     */
    TextareaView.prototype.scroll_to_bottom = function () {
        //this.$textbox.scrollTop(this.$textbox[0].scrollHeight); // DW TODO
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    TextareaView.prototype.update = function (options) {
        if (options === undefined || options.updated_view != this) {
            this.textbox.value = this.model.get('value');
            var disabled = this.model.get('disabled');
            this.textbox.disabled = disabled;
        }
        return _super.prototype.update.call(this);
    };
    TextareaView.prototype.events = function () {
        return {
            // Dictionary of events and their handlers.
            'keydown textarea': 'handleKeyDown',
            'keypress textarea': 'handleKeypress',
            'keyup textarea': 'handleChanging',
            'paste textarea': 'handleChanging',
            'cut textarea': 'handleChanging'
        };
    };
    /**
     * Handle key down
     *
     * Stop propagation so the event isn't sent to the application.
     */
    TextareaView.prototype.handleKeyDown = function (e) {
        e.stopPropagation();
    };
    /**
     * Handles key press
     *
     * Stop propagation so the keypress isn't sent to the application.
     */
    TextareaView.prototype.handleKeypress = function (e) {
        e.stopPropagation();
    };
    /**
     * Handles and validates user input.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    TextareaView.prototype.handleChanging = function (e) {
        this.model.set('value', e.target.value, { updated_view: this });
        this.touch();
    };
    return TextareaView;
}(widget_1.LabeledDOMWidgetView));
exports.TextareaView = TextareaView;
var TextModel = (function (_super) {
    __extends(TextModel, _super);
    function TextModel() {
        return _super.apply(this, arguments) || this;
    }
    TextModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _view_name: 'TextView',
            _model_name: 'TextModel'
        });
    };
    return TextModel;
}(StringModel));
exports.TextModel = TextModel;
var TextView = (function (_super) {
    __extends(TextView, _super);
    function TextView() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Called when view is rendered.
     */
    TextView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-text');
        this.textbox = document.createElement('input');
        this.textbox.setAttribute('type', 'text');
        this.el.appendChild(this.textbox);
        this.update(); // Set defaults.
        this.listenTo(this.model, 'change:placeholder', function (model, value, options) {
            this.update_placeholder(value);
        });
        this.update_placeholder();
    };
    TextView.prototype.update_placeholder = function (value) {
        if (!value) {
            value = this.model.get('placeholder');
        }
        this.textbox.setAttribute('placeholder', value);
    };
    TextView.prototype.update = function (options) {
        /**
         * Update the contents of this view
         *
         * Called when the model is changed.  The model may have been
         * changed by another view or by a state update from the back-end.
         */
        if (options === undefined || options.updated_view != this) {
            if (this.textbox.value != this.model.get('value')) {
                this.textbox.value = this.model.get('value');
            }
            var disabled = this.model.get('disabled');
            this.textbox.disabled = disabled;
        }
        return _super.prototype.update.call(this);
    };
    TextView.prototype.events = function () {
        return {
            // Dictionary of events and their handlers.
            'keydown input': 'handleKeyDown',
            'keypress input': 'handleKeypress',
            'keyup input': 'handleChanging',
            'paste input': 'handleChanging',
            'cut input': 'handleChanging',
            'blur input': 'handleBlur',
            'focusout input': 'handleFocusOut'
        };
    };
    /**
     * Handle key down
     *
     * Stop propagation so the keypress isn't sent to the application.
     */
    TextView.prototype.handleKeyDown = function (e) {
        e.stopPropagation();
    };
    /**
     * Handles text submission
     */
    TextView.prototype.handleKeypress = function (e) {
        e.stopPropagation();
        if (e.keyCode == 13) {
            this.send({ event: 'submit' });
            e.preventDefault();
        }
    };
    /**
     * Handles user input.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    TextView.prototype.handleChanging = function (e) {
        e.stopPropagation();
        this.model.set('value', e.target.value, { updated_view: this });
        this.touch();
    };
    /**
     * Prevent a blur from firing if the blur was not user intended.
     * This is a workaround for the return-key focus loss bug.
     * TODO: Is the original bug actually a fault of the keyboard
     * manager?
     */
    TextView.prototype.handleBlur = function (e) {
        if (e.relatedTarget === null) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    /**
     * Prevent a blur from firing if the blur was not user intended.
     * This is a workaround for the return-key focus loss bug.
     */
    TextView.prototype.handleFocusOut = function (e) {
        if (e.relatedTarget === null) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    return TextView;
}(widget_1.LabeledDOMWidgetView));
exports.TextView = TextView;
