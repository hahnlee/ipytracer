// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var disposable_1 = require('phosphor/lib/core/disposable');
var messages_1 = require('./messages');
/**
 * Implementation of a kernel future.
 */
var KernelFutureHandler = (function (_super) {
    __extends(KernelFutureHandler, _super);
    /**
     * Construct a new KernelFutureHandler.
     */
    function KernelFutureHandler(cb, msg, expectShell, disposeOnDone) {
        _super.call(this, cb);
        this._msg = null;
        this._status = 0;
        this._stdin = null;
        this._iopub = null;
        this._reply = null;
        this._done = null;
        this._hooks = new Private.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectShell) {
            this._setFlag(Private.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
    }
    Object.defineProperty(KernelFutureHandler.prototype, "msg", {
        /**
         * Get the original outgoing message.
         */
        get: function () {
            return this._msg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "isDone", {
        /**
         * Check for message done state.
         */
        get: function () {
            return this._testFlag(Private.KernelFutureFlag.IsDone);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onReply", {
        /**
         * Get the reply handler.
         */
        get: function () {
            return this._reply;
        },
        /**
         * Set the reply handler.
         */
        set: function (cb) {
            this._reply = cb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onIOPub", {
        /**
         * Get the iopub handler.
         */
        get: function () {
            return this._iopub;
        },
        /**
         * Set the iopub handler.
         */
        set: function (cb) {
            this._iopub = cb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onDone", {
        /**
         * Get the done handler.
         */
        get: function () {
            return this._done;
        },
        /**
         * Set the done handler.
         */
        set: function (cb) {
            this._done = cb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onStdin", {
        /**
         * Get the stdin handler.
         */
        get: function () {
            return this._stdin;
        },
        /**
         * Set the stdin handler.
         */
        set: function (cb) {
            this._stdin = cb;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Register hook for IOPub messages.
     *
     * @param hook - The callback invoked for an IOPub message.
     *
     * #### Notes
     * The IOPub hook system allows you to preempt the handlers for IOPub messages handled
     * by the future. The most recently registered hook is run first.
     * If the hook returns false, any later hooks and the future's onIOPub handler will not run.
     * If a hook throws an error, the error is logged to the console and the next hook is run.
     * If a hook is registered during the hook processing, it won't run until the next message.
     * If a hook is removed during the hook processing, it will be deactivated immediately.
     */
    KernelFutureHandler.prototype.registerMessageHook = function (hook) {
        this._hooks.add(hook);
    };
    /**
     * Remove a hook for IOPub messages.
     *
     * @param hook - The hook to remove.
     *
     * #### Notes
     * If a hook is removed during the hook processing, it will be deactivated immediately.
     */
    KernelFutureHandler.prototype.removeMessageHook = function (hook) {
        if (this.isDisposed) {
            return;
        }
        this._hooks.remove(hook);
    };
    /**
     * Dispose and unregister the future.
     */
    KernelFutureHandler.prototype.dispose = function () {
        this._stdin = null;
        this._iopub = null;
        this._reply = null;
        this._done = null;
        this._msg = null;
        if (this._hooks) {
            this._hooks.dispose();
        }
        this._hooks = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle an incoming kernel message.
     */
    KernelFutureHandler.prototype.handleMsg = function (msg) {
        switch (msg.channel) {
            case 'shell':
                this._handleReply(msg);
                break;
            case 'stdin':
                this._handleStdin(msg);
                break;
            case 'iopub':
                this._handleIOPub(msg);
                break;
        }
    };
    KernelFutureHandler.prototype._handleReply = function (msg) {
        var reply = this._reply;
        if (reply) {
            reply(msg);
        }
        this._setFlag(Private.KernelFutureFlag.GotReply);
        if (this._testFlag(Private.KernelFutureFlag.GotIdle)) {
            this._handleDone();
        }
    };
    KernelFutureHandler.prototype._handleStdin = function (msg) {
        var stdin = this._stdin;
        if (stdin) {
            stdin(msg);
        }
    };
    KernelFutureHandler.prototype._handleIOPub = function (msg) {
        var process = this._hooks.process(msg);
        var iopub = this._iopub;
        if (process && iopub) {
            iopub(msg);
        }
        if (messages_1.KernelMessage.isStatusMsg(msg) &&
            msg.content.execution_state === 'idle') {
            this._setFlag(Private.KernelFutureFlag.GotIdle);
            if (this._testFlag(Private.KernelFutureFlag.GotReply)) {
                this._handleDone();
            }
        }
    };
    KernelFutureHandler.prototype._handleDone = function () {
        if (this.isDone) {
            return;
        }
        this._setFlag(Private.KernelFutureFlag.IsDone);
        var done = this._done;
        if (done)
            done();
        this._done = null;
        if (this._disposeOnDone) {
            this.dispose();
        }
    };
    /**
     * Test whether the given future flag is set.
     */
    KernelFutureHandler.prototype._testFlag = function (flag) {
        return (this._status & flag) !== 0;
    };
    /**
     * Set the given future flag.
     */
    KernelFutureHandler.prototype._setFlag = function (flag) {
        this._status |= flag;
    };
    return KernelFutureHandler;
}(disposable_1.DisposableDelegate));
exports.KernelFutureHandler = KernelFutureHandler;
var Private;
(function (Private) {
    /**
     * A polyfill for a function to run code outside of the current execution context.
     */
    var defer = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setImmediate;
    var HookList = (function () {
        function HookList() {
            this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        HookList.prototype.add = function (hook) {
            this.remove(hook);
            this._hooks.push(hook);
        };
        /**
         * Remove a hook.
         *
         * @param hook - The callback to remove.
         */
        HookList.prototype.remove = function (hook) {
            if (this.isDisposed) {
                return;
            }
            var index = this._hooks.indexOf(hook);
            if (index >= 0) {
                this._hooks[index] = null;
                this._scheduleCompact();
            }
        };
        /**
         * Process a message through the hooks.
         *
         * #### Notes
         * The most recently registered hook is run first.
         * If the hook returns false, any later hooks will not run.
         * If a hook throws an error, the error is logged to the console and the next hook is run.
         * If a hook is registered during the hook processing, it won't run until the next message.
         * If a hook is removed during the hook processing, it will be deactivated immediately.
         */
        HookList.prototype.process = function (msg) {
            var continueHandling;
            // most recently-added hook is called first
            for (var i = this._hooks.length - 1; i >= 0; i--) {
                var hook = this._hooks[i];
                if (hook === null) {
                    continue;
                }
                try {
                    continueHandling = hook(msg);
                }
                catch (err) {
                    continueHandling = true;
                    console.error(err);
                }
                if (continueHandling === false) {
                    return false;
                }
            }
            return true;
        };
        Object.defineProperty(HookList.prototype, "isDisposed", {
            /**
             * Test whether the HookList has been disposed.
             */
            get: function () {
                return (this._hooks === null);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Dispose the hook list.
         */
        HookList.prototype.dispose = function () {
            this._hooks = null;
        };
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        HookList.prototype._scheduleCompact = function () {
            var _this = this;
            if (!this._cleanupScheduled) {
                this._cleanupScheduled = true;
                defer(function () {
                    _this._cleanupScheduled = false;
                    _this._compact();
                });
            }
        };
        /**
         * Compact the list, removing any nulls.
         */
        HookList.prototype._compact = function () {
            if (this.isDisposed) {
                return;
            }
            var numNulls = 0;
            for (var i = 0, len = this._hooks.length; i < len; i++) {
                var hook = this._hooks[i];
                if (this._hooks[i] === null) {
                    numNulls++;
                }
                else {
                    this._hooks[i - numNulls] = hook;
                }
            }
            this._hooks.length -= numNulls;
        };
        return HookList;
    }());
    Private.HookList = HookList;
    /**
     * Bit flags for the kernel future state.
     */
    (function (KernelFutureFlag) {
        KernelFutureFlag[KernelFutureFlag["GotReply"] = 1] = "GotReply";
        KernelFutureFlag[KernelFutureFlag["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag[KernelFutureFlag["IsDone"] = 4] = "IsDone";
        KernelFutureFlag[KernelFutureFlag["DisposeOnDone"] = 8] = "DisposeOnDone";
    })(Private.KernelFutureFlag || (Private.KernelFutureFlag = {}));
    var KernelFutureFlag = Private.KernelFutureFlag;
})(Private || (Private = {}));
